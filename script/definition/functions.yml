---
modern:
  strict:
    . :
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          warnings->import();
          strict->import();
          if ($] <  5.009_005) {
            require MRO::Compat;
            MRO::Compat->import;
          } elsif ($] >= 5.01) {
            require feature;
            feature->import(':5.10');
            mro::set_mro( scalar caller(2), 'c3' );
          }
        }
  -usage: |
      this is automatically used. no need to call it.
      It affects the the following to the source of caller package.
      
         use strict;
         use warnings;
         use feature (':5.10'); # if your perl version > 5.10
         mro::set_mro( scalar caller(), 'c3' );
         # or MRO::Compat->import
      
      If you want to disable this.
      
        use Util::All -modern => [];

argv:
  -require: ['Term::Encoding']
  -as_plugin : 1
  Encode::Argv:
   . :
     - |
       sub {
         my ($pkg, $class, $func, $args, $kind_args) = @_;
         my ($in, $to) = ('utf8', '');
         if (ref $kind_args eq 'ARRAY') {
            ($in, $to) = @$kind_args;
         } elsif (ref $kind_args eq 'HASH') {
            $in = $kind_args->{in} || 'utf8';
            $to = $kind_args->{to};
         } else {
            $in = $kind_args;
         }
         Encode::Argv->import($in, $to ? $to : ());
       }
  -usage: |
      make @ARGV's utf8 flag on/encode @ARGV.
      
        use Util::All -argv; # @ARGV's utf8 flag on (argument is regarded as UTF8)
        use Util::All -argv => [-args => 'euc-jp']; # @ARGV's utf8 flag on (argument is regarded as euc-jp)
        use Util::All -argv => [-args => ['utf8', 'euc-jp']]; # convert utf8 to euc-jp
        use Util::All -argv => [-args => { in => 'utf8', to => 'euc-jp'}]; # as same as the above
oo:
  Class::Data::Inheritable:
    classdata:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $cc = (caller(2))[0];
          unless ($cc->isa('Class::Data::Inheritable')) { eval "push \@${cc}::ISA, 'Class::Data::Inheritable'"; }
          $func = "mk_$func";
          sub { $cc->$func(@_); }
        }
  Class::Accessor::Fast:
    accessors:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $cc = (caller(2))[0];
          unless ($cc->isa('Class::Accessor::Fast')) { eval "push \@${cc}::ISA, 'Class::Accessor::Fast'"; }
          $func = "mk_$func";
          sub { $cc->$func(@_); }
        }
    ro_accessors:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $cc = (caller(2))[0];
          $func = "mk_$func";
          sub { $cc->$func(@_); }
        }
    wo_accessors:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $cc = (caller(2))[0];
          $func= "mk_$func";
          sub { $cc->$func(@_); }
        }
  -usage: |
      provides simple OO interface.
      constructor and accessors is provided as wrapper of L<Class::Accessor::Fast> and L<Class::Data::Inheritable>.
      
      =head3 new
      
        my $o = YourClass->new({foo => 1, bar => 1, buz => 2});
      
      constructor.
            
      =head3 accessors
      
        accessors(qw/foo bar buz/);
      
      create get/set accessors.

      =head3 ro_accessors
      
        ro_accessors(qw/foo bar buz/);
      
      create get accessors.

      =head3 wo_accessors
      
        wo_accessors(qw/foo bar buz/);
      
      create set accessors.
      
      =head3 classdata
      
        classdata(qw/Foo/);
      
      create class data(Class::Data::Inheritable).
      
  -test:
    -
      - package Hoge1; use Util::All -oo; accessors("foo", "bar"); my $o = Hoge1->new; $o->foo(100); $o->bar("ABC"); ($o->foo, $o->bar);
      - (100, "ABC");
    -
      - package Hoge2; use Util::All -oo; ro_accessors("foo", "bar"); my $o = Hoge2->new({foo => 200, bar => 300}); ($o->foo, $o->bar);
      - (200, 300);
    -
      - package Hoge3; use Util::All -oo; wo_accessors("foo", "bar"); my $o = Hoge3->new; ($o->foo(300), $o->bar(400));
      - (300, 400);
    -
      - package Hoge4; use Util::All -oo; ro_accessors("foo", "bar"); my $o = Hoge2->new({foo => 200, bar => 300}); eval {($o->foo(300), $o->bar(400))}; if($@){1}else{0};
      - 1;
    -
      - package Hoge5; use Util::All -oo; wo_accessors("foo", "bar"); my $o = Hoge3->new; ($o->foo(300), $o->bar(400)); eval {($o->foo, $o->bar)}; if($@){1}else{0};
      - 1;
    -
      - package Hoge6; use Util::All -oo; classdata("Foo"); Hoge6->Foo("foo!"); Hoge6->Foo;
      - '"foo!"'
    -
      - package Hoge7; use Util::All -oo; classdata("Foo"); Hoge7->Foo("foo!"); package Hoge8; push @Hoge8::ISA, 'Hoge7'; my $s = Hoge8->Foo; Hoge8->Foo(100); $s.= Hoge8->Foo . Hoge7->Foo;
      - '"foo!100foo!"'

data:
  -as_plugin : 1
  Data::Structure::Util:
    -select:
      - has_utf8
      - unbless
  Data::Util:
    -select:
      - is_scalar_ref
      - is_array_ref
      - is_hash_ref
      - is_code_ref
      - is_glob_ref
      - is_rx
      - is_instance
      - is_invocant
      - is_value
      - is_string
      - is_number
      - is_integer
  Scalar::Util:
    -select:
      - dualvar
      - looks_like_number
      - openhandle
      - refaddr
      - reftype
      - set_prototype
      - weaken
    isvstring: is_vstring
    isweak  : is_weak
    tainted : is_tainted
    readonly: is_readonly
    blessed : is_blessed

subroutine:
  -as_plugin : 1
  Data::Util:
    -select:
      - install_subroutine
      - uninstall_subroutine
      - get_code_info
      - get_code_ref
      - curry
      - modify_subroutine
      - subroutine_modifier

list:
  -as_plugin : 1
  List::Util:
    - first
    - max
    - maxstr
    - min
    - minstr
    - reduce
    - shuffle
    - sum
  List::MoreUtils:
    - after
    - after_incl
    - all
    - any
    - apply
    - before
    - before_incl
    - each_array
    - each_arrayref
    - false
    - first_index
    - first_value
    - firstidx
    - firstval
    - indexes
    - insert_after
    - insert_after_string
    - last_index
    - last_value
    - lastidx
    - lastval
    - mesh
    - minmax
    - natatime
    - none
    - notall
    - pairwise
    - part
    - true
    - uniq
    - zip
  List::Pairwise:
    - mapp
    - grepp
    - firstp
    - lastp
    - pair
hash:
  -as_plugin : 1
  Hash::Util:
    -select:
     - hash_seed
     - lock_hash
     - lock_keys
     - lock_value
     - unlock_hash
     - unlock_keys
     - unlock_value
  Tie::IxHash:
    indexed:
      - |
        sub {
          sub (\%@) {
            my $hash = shift;
            tie %$hash, "Tie::IxHash";
            %$hash = @_;
          }
        }
      - usage:
        - indexed my %hash = (a => 1, b => 2);
        - '%hash is indexed.'
      - test:
        -
          - indexed my %hash; %hash = qw/5 1 4 2 3 3 2 4 1 5 0 6/;  keys %hash
          - qw/5 4 3 2 1 0/
debug:
  -as_plugin : 1
  -require: ['B::Deparse']
  Data::Dumper:
    Dumper:
      - dumper
      - usage:
        - dumper(@variables)
        - Dumper in L<Data::Dumper>.
    deep_dumper:
      - sub { sub(@) { local $Data::Dumper::Deparse = 1; Data::Dumper::Dumper(@_)} }
      - usage:
        - deep_dumper([1 , 2, sub { print "hello World" }])
        - dump code reference as string. 
#    moose_dumper:
#      - |
#        sub {
#          # written by lesttrat at #soozy on freenode
#          local $Data::Dumper::Sortkeys = sub {
#            my ($hash) = @_;
#            return [ grep { $_ ne '__MOP__' } keys %$hash ];
#          };
#          sub {
#            Data::Dumper::Dumper(@_);
#          }
#        }
#      - usage:
#        - moose_dumper($moose_object)
#        - dump $moose_object except __MOP__
    ex_dumper:
      - |
        sub {
          sub {
            my $keys = pop;
            my %tmp;
            @tmp{@$keys} = ();
            local $Data::Dumper::Sortkeys = sub {
              my ($hash) = @_;
              return [ grep {not exists $tmp{$_}} keys %$hash ];
            };
            Data::Dumper::Dumper(@_);
          }
        }
      - usage:
        - |
          ex_dumper($data, \@keys);
          ex_dumper($data, ['__MOP__']);
        - dump $data except @keys of hash
      - test:
        - 
          - use Util::All -debug; my $d = ex_dumper({hoge => 1, fuga => 2, foo => {hoge => 3}}, ['hoge']); my $VAR1; eval "$d";
          - '{fuga => 2, foo => {}}'
  Data::Dump:
    -select:
      - dump
      - usage:
        - 
          - print dump(@vars);
          - dump(@vars);
        - |
          dump of L<Data::Dump>. 
          dump structure. In later case, result is dumped to STDERR.
      - pp
      - usage:
        - pp("{ x => 1, y => 2, z => 3}");
        - dump after given string is evaled.
      - dd
      - usage:
        - dd(@vars);
        - |
          dd of L<Data::Dump>.
          as same as dump but output to STDOUT.
      - ddx
      - usage:
        - dd(@vars);
        - |
          ddx of L<Data::Dump>.
          as same as dd but output to STDOUT with line number.
    p:
      - sub { sub(@) { Data::Dump::dump(@_) } }
      - p($variable)
      - as same as dump(function name is borrowed from Ruby).
    deep_dump:
      - |
        sub {
           require Data::Dumper;
           sub(@) {
             local $Data::Dumper::Deparse = 1;
             local $Data::Dumper::Terse = 1;
             if (not defined wantarray) {
               print STDERR Data::Dumper::Dumper(@_);
             } else {
               return Data::Dumper::Dumper(@_)
             }
          }
        }
      - usage:
        - deep_dump([1,2,3, sub { ... } ]);
        - as same as dump. but it dump code reference as string.
  Tie::Trace:
    -select: ['watch']
  Devel::Size:
    -select: ['size', 'total_size']
  Devel::Cycle:
    -select: ['find_cycle']

dumper:
 -alias_of: ['debug', 'Data::Dump']

string:
  -as_plugin: 1
  String::Util:
    -select:
      - crunch
      - define
      - equndef
      - fullchomp
      - hascontent
      - htmlesc
      - neundef
      - nospace
      - randcrypt
      - randword
      - trim
      - unquote
    strings:
      - |
        sub {
          sub {
            my $str = shift;
            $str =~ s/\p{Cc}//g;
            return $str;
          }
        }
      - usage:
        - strings("111\0111"); # return "111111"
        - abstract printable character from scalar. just like strings command.
      - test:
        -
          - package test_strings1; use Util::All -string; strings('111' . "\0" . '111');
          - '"111111"'
  IO::String:
    to_fh:
      - |
        sub {
          require LWP::Simple;
          require IO::File;
          sub {
            my $opt = $_[-1] =~m{^[rw+<>]+$} ? pop : '<';
            if (@_ == 1) {
              my $target = $_[0];
              if (ref $target eq 'SCALAR') {
                return IO::String->new($target);
              } elsif ($target !~ m{[\r\n]} and -e $target) {
                return $IO::File->new($target, $opt);
              } else {
                return IO::String->new(\$_[0]);
              }
            } else {
              my %type = @_;
              if (defined $type{url}) {
                my $scalar = LWP::Simple::get($type{url});
                return IO::String->new(\$scalar);
              } elsif (defined $type{file}) {
                return IO::File->new($type{file}, $opt);
              }
            }
          }
        }
      - usage:
         - |
           my $fh = to_fh($scalar);
           print $_ while <$fh>;
           
           to_fh(url  => "http://example.co.jp/");
           to_fh(file => "/path/to/target.txt");
           to_fh(file => "/path/to/target.txt", '>');

         - create IO::String object, which can be used as filehandle.
      - test:
        - 
          - use Util::All -string; my $s = "1\n2\n3\n4\n5\n"; my $fh = to_fh($s); my $sum = 0; while (<$fh>){ chomp; $sum += $_ ; $sum++}; $sum;
          - 20
        -
          - use Util::All -string; my $s = "1\n2\n3\n4\n5\n"; my $fh = to_fh(\$s); my $sum = 0; while (<$fh>){ chomp; $sum += $_ ; $sum++}; $sum;
          - 20
        -
          - use Util::All -string; my $fh = to_fh(url => "http://rwds.net/"); my $c = ''; while (<$fh>){m{<h1>(.+)</h1>} and do {$c = $1; last} }; $c;
          - '"rwds.net"'
  String::CamelCase:
    - camelize
    - decamelize
    - wordsplit

md5:
  -as_plugin : 1
  Digest::MD5:
    - md5
    - md5_hex
    - md5_base64
sha:
  -as_plugin : 1
  Digest::SHA:
    - sha1
    - sha1_hex
    - sha1_base64
    - sha256
    - sha256_hex
    - sha256_base64
    - sha384
    - sha384_hex
    - sha384_base64
    - sha512
    - sha512_hex
    - sha512_base64

utf8:
  utf8:
    is_utf8  : is_utf8
    upgrade  : utf8_upgrade
    downgrade: utf8_downgrade
    encode   : utf8_encode
  Data::Recursive::Encode:
    utf8_on  :
      - sub {sub {Data::Recursive::Encode->decode_utf8(@_)}}
      - my $d = utf8_on($data);
      - recursively make utf8 flag on(not destructive)
    utf8_off :
      - sub {sub {Data::Recursive::Encode->encode_utf8(@_)}}
      - my $d = utf8_off($data);
      - recursively make utf8 flag off(not destructive)
  -test:
    -
      - package test_utf8_1; use Util::All -utf8; my $data = { a => "あ", b => {c => "い"}}; my $d = utf8_on($data); is_utf8($d->{a}) && is_utf8($d->{b}{c});
      - 1
    -
      - package test_utf8_2; use utf8; use Util::All -utf8; my $data = { a => "あ", b => {c => "い"}}; my $d = utf8_off($data); is_utf8($d->{a}) || is_utf8($d->{b}{c});
      - "''"

unicode:
   -as_plugin : 1
   Unicode::String: 
     -select: [ utf32be, utf32le, utf16be, utf16le, utf8, utf7, latin1, uhex, uchr ]
   Unicode::CharName:
     unicode_name: |
       sub {
          require Unicode::CharName;
          require Encode;
          sub {
            my $s = shift;
            Unicode::CharName::uname($s =~m{\D} ? ord(utf8::is_utf8($s) ? $s : Encode::decode("utf8", $s)) : $s);
          }
       }
     unicode_block: |
       sub {
          require Unicode::CharName;
          require Encode;
          sub {
            my $s = shift;
            Unicode::CharName::ublock($s =~m{\D} ? ord(utf8::is_utf8($s) ? $s : Encode::decode("utf8", $s)) : $s);
          }
       }
   -usage: |
    Unicode operation using Unicode::Stirng.

      utf32be($str)->utf8;      # utf32be -> utf8 (byte string)
      utf32le($str)->utf16le;   # utf32le -> utf16le (byte string)
      utf16be($str)->utf8;      # utf16be -> utf8 (byte string)
      utf16le($str)->utf32be;   # utf16le -> utf32be (byte string)
      uhex(2026)->utf8;         # equal to "…"
      uchr(8230)->utf8;         # equal to "…"

    If you want unicode name/block.

      nicode_name(ord("\x{2026}"));  # equal to 'HORIZONTAL ELLIPSIS'
      nicode_name('…');              # equal to 'HORIZONTAL ELLIPSIS'
      nicode_block(8230);            # equal to 'General Punctuation'
      nicode_block('…');            # equal to 'General Punctuation'

cgi:
  -as_plugin : 1
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape
  HTML::Entities:
    decode_entities: decode_html_entities
    encode_html_entities:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $_words = $args->{words} || $kind_args->{words};
          sub {
            my ($str, $words) = @_;
            utf8::decode($str)  if not utf8::is_utf8($str);
            $str = HTML::Entities::encode_entities($str, $words || $_words);
            unless (defined wantarray) {
              my $ref = \$_[0];
              $$ref = $str;
            }
            return $str;
          }
        }
      - test:
        -
          - package AAA; no utf8; use Util::All -cgi; encode_html_entities("あいうえお");
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - package BBB; use utf8; use Util::All -cgi; encode_html_entities("あいうえお");
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - package CCC; no utf8; use Util::All -cgi; encode_html_entities(my $s = "あいうえお"); $s;
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - package DDD; use utf8; use Util::All -cgi; encode_html_entities(my $s = "あいうえお"); $s;
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - package EEE; no utf8; use Util::All -cgi; decode_html_entities(encode_html_entities("あいうえお"));
          - use utf8; 'あいうえお'
        -
          - package FFF; use utf8; use Util::All -cgi; decode_html_entities(encode_html_entities("あいうえお"));
          - use utf8; 'あいうえお'
        -
          - package GGG; no utf8; use Util::All -cgi; my $str = "あいうえお"; encode_html_entities($str); $str;
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - package HHH; no utf8; use Util::All -cgi; my $str = "あいうえお"; scalar encode_html_entities($str); $str;
          - no utf8; 'あいうえお'
        -
          - package III; no utf8; use Util::All -cgi => [encode_html_entities => {words => "<>"}]; my $str = "あいうえお<&>"; encode_html_entities($str);
          - use utf8; 'あいうえお&lt;&&gt;'
        -
          - package JJJ; no utf8; use Util::All -cgi => [-args => {words => "<>"}]; my $str = "あいうえお<&>"; encode_html_entities($str);
          - use utf8; 'あいうえお&lt;&&gt;'
        -
          - package KKK; no utf8;use Util::All -cgi => [-args => {words => "<>"}]; my $str = "あいうえお<&>"; encode_html_entities($str, "&");
          - use utf8; 'あいうえお<&amp;>'
  -usage: |
    =head3 encode_html_entities
    
      my $new_str = encode_html_entities($str, $words);
      encode_html_entities($str, $words);
    
    encode HTML entity. in void context, it modify argument itself.
    this function assumes given argument charset is utf8(utf8 flag on or off).
    
    =head3 decode_html_entities
    
      @new_args = decode_html_entities(@args);
      decode_html_entities(@args);
    
    decode HTML entity.  in void context, it modify argument itself.
   
xml:
  -as_plugin: 1
  -require: ['XML::Parser', 'String::CamelCase']
  XML::Simple:
    from_xml:
     -  |
      sub {
        require String::CamelCase;
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        local $XML::Simple::XML_SIMPLE_PREFERRED_PARSER = $args->{parser} || $kind_args->{parser} || 'XML::Parser';
        my %new_args;
        if (not     defined($new_args{ForceArray} = $args->{ForceArray})
            and not defined($new_args{ForceArray} = $args->{force_array})
            and not defined($new_args{ForceArray} = $kind_args->{ForceArray})
            and not defined($new_args{ForceArray} = $kind_args->{force_array})
        ) {
          $new_args{ForceArray} = 1
        }
        if (not     defined($new_args{KeyAttr} = $args->{KeyAttr})
            and not defined($new_args{KeyAttr} = $args->{key_attr})
            and not defined($new_args{KeyAttr} = $kind_args->{KeyAttr})
            and not defined($new_args{KeyAttr} = $kind_args->{key_attr})
        ) {
          delete $new_args{KeyAttr};
        }
        sub {
          my ($file, %args) = @_;
          $args{String::CamelCase::camelize($_)} = delete $args{$_} for keys %args;
          XML::Simple::XMLin($file, (%new_args, %args));
        }
      }
     - usage:
       - |
         use Util::All -xml;
         
         $data = from_xml('hoge.xml');
         $data = from_xml('hoge.xml', force_array => 0, key_attr => 'id'); # force_array is 1 as default.
         
         use Util::All -xml => [-args => {parser => 'XML::Parser', force_array => 0, key_attr => "id"}];
         
         $data = from_xml('hoge.xml');

       - parse XML file with XML::Simple.
    to_xml:
     - |
      sub {
        require String::CamelCase;
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        if (not defined($args->{ForceArray} ||= $kind_args->{force_array})) {
          if (not defined($args->{ForceArray} ||= $args->{force_array})) {
            $args->{ForceArray} = 1;
          }
        }
        sub {
          my ($data, %args) = @_;
          $args{String::CamelCase::camelize($_)} = delete $args{$_} for keys %args;
          XML::Simple::XMLout($data, %$args, %args);
        }
      }
     - usage:
       - |
         use Util::All -xml;
         
         my $xml = to_xml(\%structure);
         my $xml = to_xml(\%structure, force_array => 0, key_attr => 'id');
         
         use Util::All -xml => [-args => {parser => 'XML::Parser', force_array => 0, key_attr => "id"}];
         my $xmls = to_xml(\%structure);

       - |
         parse XML file with XML::Simple. If xml has key attribute, you can pass key_attr => $key_name,
         then this return hash ref instead of array ref. As default, attribute name "id" is regarded as key attribute.
         This function pass force_array => 1 to XML::Simple, If you don't want it, give force_array => 0 as option,

  -test:
    -
      - package xml_test1; use Util::All -xml => [-args => {force_array => 1, key_attr => "hoge"}]; from_xml("t/data/test.xml");
      - '{"parent" => { "1" => {"child" => ["1"]}, "2" => {"child" => ["2","40","50"]}}};'
    -
      - package xml_test2; use Util::All -xml => [-args => {force_array => 0, key_attr => "hoge"}]; from_xml("t/data/test.xml");
      - '{"parent" => { "1" => {"child" => "1"}, "2" => {"child" => ["2","40","50"]}}};'
    -
      - package xml_test3; use Util::All -xml; from_xml("t/data/test.xml");
      - '{"parent" => [{hoge => 1, "child" => ["1"]}, {hoge => 2, "child" => ["2","40","50"]}]};'
    -
      - package xml_test4; use Util::All -xml;from_xml("t/data/test.xml", force_array => 0, key_attr => "hoge");
      - '{"parent" => { "1" => {"child" => "1"}, "2" => {"child" => ["2","40","50"]}}};'

encode:
  Encode:
    - encode
    - decode
    - from_to

charset:
  -as_plugin : 1
  Encode:
    encode: char_encode
    decode: char_decode
    jfold:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          sub {
            my ($str, $width, $nl) = @_;
            $width ||= $args->{width} || $kind_args->{width};
            $nl ||= $args->{nl} || $kind_args->{nl} || "\n";
            my $is_utf8 = 0;
            utf8::decode($str) if not $is_utf8 = utf8::is_utf8($str);
            my $cnt = 0;
            my @lines;
            my $l = '';
            foreach my $s ($str =~ m{(.)}g) {
              if ($s =~ m{\p{ASCII}} or ($s =~ m{\p{InHalfwidthAndFullwidthForms}} and $s !~ m{[\p{Lu}\p{Ll}\p{LC}\p{Lt}\p{Lm}\p{S}\p{P}\p{N}]})) {
                 $cnt ++;
              } else {
                 $cnt += 2;
              }
              $l .= $s;
              if ($cnt >= $width) {
                push @lines, $l;
                $cnt = 0;
                $l   = '';
              }
            }
            push @lines, $l if $l;
            return $is_utf8 ? join $nl, @lines : Encode::encode("utf8", join $nl, @lines);
          }
        }

    char_convert:
      - |
        sub {
           my ($pkg, $class, $func, $args) = @_;
           my $g_class = 0;
           if (exists $args->{guess}){
             require Encode::Guess;
             Encode::Guess->import(@{$args->{guess}});
           } elsif (not $INC{"Encode/Detect.pm"} and not $INC{"Encode/Guess.pm"}) {
             eval {require Encode::Detect; $g_class = 1} or require Encode::Guess;
           }
           sub {
             my ($str, $to, $from) = @_;
             if (ref $str and utf8::is_utf8($$str)) {
               utf8::encode($$str);
             } elsif (utf8::is_utf8($str)) {
               utf8::encode($str);
             }
             Encode::from_to(ref $str ? $$str : $str, $from ? $from : $g_class ? "DETECT" : "GUESS", $to);
             return $str;
           }
        }
    from_to: char_from_to
  Unicode::Japanese:
   z2h:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2h->$method;
        }
      }
   z2h_kana:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hKana->$method;
        }
      }
   z2h_alpha:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hAlpha->$method;
        }
      }
   z2h_sym:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hSym->$method;
        }
      }
   z2h_num:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hNum->$method;
        }
      }
   h2z:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2z->$method;
        }
      }
   h2z_kana:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zKana->$method;
        }
      }
   h2z_alpha:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zAlpha->$method;
        }
      }
   h2z_sym:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zSym->$method;
        }
      }
   h2z_num:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zNum->$method;
        }
      }
  -usage: |
    =head3 char_encode / char_decode

    They are encode / decode of Encode.

    =head3 char_convert
    
    old Jocde style function.
    
     $new_str = char_convert($str, "euc-jp"); # to euc-jp
     $new_str = char_convert($str, "euc-jp", "sjis"); # to euc-jp from sjis
    
    convert $str to second argument charset. third argument is charset of $str.
    when third argument is omitted, Encode::Detect(if installed) or Encode::Guess is used to detect charset.
    
    =head3 z2h functions
    
     z2h($str);       # return the value replaced zenkaku to hankaku
     z2h_kana($str);  # return the value replaced zenkaku kana hankaku
     z2h_num($str);   # return the value replaced zenkaku number hankaku
     z2h_sym($str);   # return the value replaced zenkaku symbol hankaku
     z2h_alpha($str); # return the value replaced zenkaku alphabet hankaku

    If $str is utf8 flag on, return utf flagged value, if not return byte string.

    =head3 h2z functions

     h2z($str);       # return the value replaced hankaku to zenkaku
     h2z_kana($str);  # return the value replaced hankaku kana zenkaku
     h2z_num($str);   # return the value replaced hankaku number zenkaku
     h2z_sym($str);   # return the value replaced hankaku symbol zenkaku
     h2z_alpha($str); # return the value replaced hankaku alphabet zenkaku

    If $str is utf8 flag on, return utf flagged value, if not return byte string.
   
    =head3 jfold
      
     jfold($sentence, $width, $new_line_char);
     jfold("アイウエオ１２３４ABCD（）＊＆", 4); # "アイ\nウエ\nオ１\n２３\n４AB\nCD（\n）＊\n＆"
   
    This folds sentence. This regards full-width char as 2 and half-width char as 1.
    The given string must be utf-8(flagged or non flagged).
    
    You can give default $width and/or $new_line_char.
    
     use Util::All -charset => [jfold => {width => 4, nl => "\t"}];
     
     jfold($str);
     jfold("アイウエオ１２３４ABCD（）＊＆"); # "アイ\tウエ\tオ１\t２３\t４AB\tCD（\t）＊\t＆";
   
  -test:
    -
      - package AAA; use Util::All -charset; jfold("アイウエオ１２３４ABCD（）＊＆", 4);
      - '"アイ\nウエ\nオ１\n２３\n４AB\nCD（\n）＊\n＆"'
    -
      - package BBB; use Util::All -charset; jfold("ｱｲｳｴｵ１２３４ＡＢＣＤ（）＊", 4);
      - '"ｱｲｳｴ\nｵ１２\n３４\nＡＢ\nＣＤ\n（）\n＊"'
    - 
      - package CCC; use Util::All -charset; jfold("～！＠＃＄％＾＆＊（）＿＋＝ー／＼；？＞＜。、，．：｛｝「」［］｜『』《》〔〕", 4);
      - '"～！\n＠＃\n＄％\n＾＆\n＊（\n）＿\n＋＝\nー／\n＼；\n？＞\n＜。\n、，\n．：\n｛｝\n「」\n［］\n｜『\n』《\n》〔\n〕"'
    -
      - package DDD; use Util::All -charset; jfold("アイウエオ１２３４ABCD（）＊＆", 4, "\t");
      - '"アイ\tウエ\tオ１\t２３\t４AB\tCD（\t）＊\t＆"'
    -
      - package EEE; use utf8; use Util::All -charset; jfold("アイウエオ１２３４ABCD（）＊＆", 4, "\t");
      - use utf8; "アイ\tウエ\tオ１\t２３\t４AB\tCD（\t）＊\t＆"
    -
      - package FFF; no utf8; use Util::All -charset; jfold("アイウエオ１２３４ABCD（）＊＆", 4, "\t");
      - no utf8; "アイ\tウエ\tオ１\t２３\t４AB\tCD（\t）＊\t＆"
    -
      - package GGG; package charset_jfold; use Util::All -charset => [jfold => {width => 4, nl => "\t"}]; jfold("アイウエオ１２３４ABCD（）＊＆");
      - no utf8; "アイ\tウエ\tオ１\t２３\t４AB\tCD（\t）＊\t＆"
    - 
      - my $ss = char_convert(my $s = "あ", "euc-jp"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "euc-jp"); $s;
    - 
      - my $ss = char_convert(my $s = "あ", "cp932", "utf8"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "cp932"); $s;
    -              
      - use utf8; my $ss = char_convert(my $s = "あ", "euc-jp"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "euc-jp"); $s;
    - 
      - use utf8; my $ss = char_convert(my $s = "あ", "cp932", "utf8"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "cp932"); $s;
    - 
      - my $ss = char_convert(\(my $s = "あ"), "euc-jp"); $$ss eq $s
      - 1;
    -
      - z2h('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'ｱｲｳｴｵ1234ABCD()*&'"
    -
      - z2h_alpha('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'アイウエオ１２３４ABCD（）＊＆'"
    -
      - z2h_sym('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'アイウエオ１２３４ＡＢＣＤ()*&'"
    -
      - z2h_num('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'アイウエオ1234ＡＢＣＤ（）＊＆'"
    -
      - z2h_kana('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'ｱｲｳｴｵ１２３４ＡＢＣＤ（）＊＆'"
    -
      - h2z('ｱｲｳｴｵ1234ABCD()*&')
      - "'アイウエオ１２３４ＡＢＣＤ（）＊＆'"
    -
      - h2z_alpha('ｱｲｳｴｵ1234ABCD()*&')
      - "'ｱｲｳｴｵ1234ＡＢＣＤ()*&'"
    -
      - h2z_sym('ｱｲｳｴｵ1234ABCD()*&')
      - "'ｱｲｳｴｵ1234ABCD（）＊＆'"
    -
      - h2z_num('ｱｲｳｴｵ1234ABCD()*&')
      - "'ｱｲｳｴｵ１２３４ABCD()*&'"
    -
      - h2z_kana('ｱｲｳｴｵ1234ABCD()*&')
      - "'アイウエオ1234ABCD()*&'"
    -
      - use utf8; z2h('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - use utf8; 'ｱｲｳｴｵ1234ABCD()*&'
    -
      - use utf8; z2h('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - use utf8; 'ｱｲｳｴｵ1234ABCD()*&'

uri:
  -as_plugin: 1
  URI::Escape:
    - uri_escape
    - uri_unescape
  URI::Split:
    - uri_split
    - uri_join
  URI:
    make_query:
      - |
        sub {
          require URI::QueryParam;
          sub {
            use utf8;
            my($form) = @_;
            my $u = URI->new('', 'http');
            foreach my $k (keys %$form) {
              my($key, $value) = ($k, $$form{$k});
              utf8::encode($key)   if utf8::is_utf8($k);
              my @value = ref $value ? @$value : $value;
              for (@value) {utf8::encode($_) if  utf8::is_utf8($_)}
              $u->query_param($key => @value);
            }
            $u->query;
          }
        }
      - usage:
        - make_query({foo => "あ", bar => ["い", "う"]}); # return 'bar=%E3%81%86&bar=%E3%81%84&foo=%E3%81%82'
        - create query parameter from hash.
      - test:
        - 
          - make_query({foo => "あ", bar => ["い", "う"]});
          - ('bar=%E3%81%86&bar=%E3%81%84&foo=%E3%81%82')
        - 
          - my $x = "あ"; utf8::decode($x); make_query({foo => $x});
          - ('foo=%E3%81%82')
    make_uri:
      - |
        sub {
          if (URI->VERSION <= 1.35) {
            sub {
              use utf8;
              my ($url, $form) = @_;
              my %form;
              foreach my $k (keys %$form) {
                my ($key, $value) = ($k, $form->{$k});
                utf8::encode($key)   if utf8::is_utf8($k);
                utf8::encode($value) if utf8::is_utf8($value);
                $form{$key} = $value;
              }
              my $u = URI->new($url);
              $u->query_form(%form);
              $u->as_string;
            }
          } else {
            sub {
              use utf8;
              my ($url, $form) = @_;
              my %form;
              foreach my $k (keys %$form) {
                my ($key, $value) = ($k, $form->{$k});
                utf8::decode($key)   unless utf8::is_utf8($k);
                utf8::decode($value) unless utf8::is_utf8($value);
                $form{$key} = $value;
              }
              my $u = URI->new($url);
              $u->query_form(%form);
              $u->as_string;
            }
          }
        }
      - usage:
        - uri_make('http://example.com/', { foo => "あ", bar => "い"}); # return 'http://example.com/?bar=%E3%81%84&foo=%E3%81%82'
        - create URI with parameter.
      - test:
        - 
          - make_uri('http://example.com/', { foo => "あ", bar => "い"});
          - ('http://example.com/?bar=%E3%81%84&foo=%E3%81%82')
        - 
          - my $x = "あ"; utf8::decode($x); make_uri('http://example.com/', { foo => $x});
          - ('http://example.com/?foo=%E3%81%82')

base64:
  -as_plugin: 1
  MIME::Base64:
    encode_base64: base64_encode
    decode_base64: base64_decode
  MIME::Base64::URLSafe:
    urlsafe_b64encode: urlsafe_base64_encode
    urlsafe_b64decode: urlsafe_base64_decode

http:
  -as_plugin: 1
  -require : ['LWP::UserAgent']
  -usage : |
      =head3 http_* functions
      
      do http method and get HTTP::Response object.
      
        http_get($url, \%query);
        http_post($url, \%query);
        http_put($url, \%query);
        http_delete($url, \%query);
        http_head($url, \%query);
  HTTP::Request::Common:
    http_put   : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::PUT(@_)) } }
    http_delete: sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::DELETE(@_)) } }
    http_head  : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::HEAD(@_)) } }
    http_get   : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::GET(@_)) } }
    http_post  : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::POST(@_)) } }
#  WWW::Curl::Simple is faster, but hard to install:
#    http_get   : sub { require WWW::Curl::Simple; my $ua = WWW::Curl::Simple->new(); sub { $ua->get(@_) } }
#    http_post  : sub { require WWW::Curl::Simple; my $ua = WWW::Curl::Simple->new(); sub { $ua->post(@_) } }

carp:
  Carp:
    - croak
    - cluck
    - carp
    - confess
#    - shortmess
#    - longmess

yaml:
  -require: ['File::Slurp', 'Data::Structure::Util']
  -as_plugin: 1
  YAML::XS:
    Dump: encode_yaml
    Load: decode_yaml
    from_yaml_file:
      - sub {require File::Slurp; sub ($) { YAML::XS::Load(scalar File::Slurp::slurp(shift)) }}
      - from_yaml_file($yaml_file);
      - load YAML data from file
    to_yaml_file:
      - |
        sub { require Encode; require Data::Structure::Util; require Data::Recursive::Encode;
           sub {
              my ($data, $file) = @_;
              $data = Data::Recursive::Encode->decode('utf8', $data) unless Data::Structure::Util::has_utf8($data);
              File::Slurp::write_file($file, YAML::XS::Dump($data));
           }
        }
      - to_yaml_file($data, $yaml_file);
      - dump YAML data to file
    from_yaml:
      - |
        sub { require Encode;
           sub {
              my $yaml = shift;
              YAML::XS::Load(utf8::is_utf8($yaml) ? Encode::encode("utf8", $yaml) : $yaml);
           }
        }
    to_yaml:
      - |
        sub { require Encode; require Data::Structure::Util; require Data::Recursive::Encode;
           sub {
              my $data = shift;
              $data = Data::Recursive::Encode->decode('utf8', $data) unless Data::Structure::Util::has_utf8($data);
              YAML::XS::Dump($data);
           }
        }
  -test:
    -
      - 'no utf8; from_yaml( qq{---\nhoge: あ\n} );'
      - use utf8; { hoge => 'あ' };
    -
      - 'use utf8; from_yaml( qq{---\nhoge: あ\n} );'
      - use utf8; { hoge => 'あ' };
    -
      - 'no utf8; decode_yaml( qq{---\nhoge: あ\n} );'
      - use utf8; { hoge => 'あ' };
    -
      - no utf8; to_yaml({hoge => 'あ'})
      - 'no utf8; qq{---\nhoge: あ\n}'
    -
      - use utf8; to_yaml({hoge => 'あ'})
      - 'no utf8; qq{---\nhoge: あ\n}'
    -
      - use utf8; encode_yaml({hoge => 'あ'})
      - 'no utf8; qq{---\nhoge: あ\n}'
    - 
      - from_yaml_file("t/data/test.yml");
      - use utf8; {hoge => 'あ'};
    - 
      - use utf8; to_yaml_file({hoge => "あいうえお"}, "t/data/test.out.yml"); from_yaml_file("t/data/test.out.yml");
      - use utf8; {hoge => "あいうえお"}
    - 
      - no utf8; to_yaml_file({hoge => "あいうえお"}, "t/data/test.out.yml"); from_yaml_file("t/data/test.out.yml");
      - use utf8; {hoge => "あいうえお"}

yml:
  -as_plugin: 1
  -alias_of: yaml

json:
  -as_plugin: 1
  -require: ['File::Slurp', 'Encode', 'Data::Structure::Util']
  JSON::XS:
    -select:
      - encode_json
      - decode_json
    from_json:
      - |
        sub {
          sub {
            my $d = shift;
            JSON::XS->new->utf8(!utf8::is_utf8($d))->decode($d);
          }
        }
      - from_json($json_text);
      - from json text to perl data(utf8 flagged).
    to_json:
      - |
        sub { require Data::Structure::Util; require Encode;
          sub {
             my $d = shift;
             Data::Structure::Util::has_utf8($d)
                 ? JSON::XS::encode_json($d)
                 : Encode::encode("latin1", Encode::decode("utf8", JSON::XS::encode_json($d)))
          }
        }
      - to_json($perl_data);
      - from perl data to json text(utf8 encoded).
    from_json_file:
      - |
        sub {require File::Slurp;
          sub ($) {
             JSON::XS::decode_json(scalar File::Slurp::slurp(shift))
          }
        }
      - from_json_file($json_file);
      - load JSON data from file. returns Perl data whose utf8 flag is off.
    to_json_file:
      - |
        sub {require File::Slurp; require Encode; require Data::Structure::Util;
           sub {
             my $d = shift;
             my $f = shift;
             File::Slurp::write_file( $f, Data::Structure::Util::has_utf8($d)
                                          ? JSON::XS::encode_json($d)
                                          : Encode::encode("latin1", Encode::decode("utf8", JSON::XS::encode_json($d))) );
           }
        }
      - to_json_file($data, $file);
      - write JSON to file.
  -test:
    -
      - 'no utf8; from_json(q/{"hoge":"あ"}/);'
      - use utf8; {hoge => "あ"}
    -
      - 'use utf8; from_json(q/{"hoge":"あ"}/);'
      - use utf8; {hoge => "あ"}
    -
      - no utf8; to_json({hoge => 'あ'});
      - no utf8; qq{{"hoge":"あ"}}
    -
      - use utf8; to_json({hoge => 'あ'});
      - no utf8; qq{{"hoge":"あ"}}
    - 
      - no utf8; to_json_file({hoge => "あいうえお"}, "t/data/test.out.json"); from_json_file("t/data/test.out.json");
      - 'use utf8; {hoge => "あいうえお"}'

math:
  -as_plugin: 1
  Toolbox::Simple:
    -select: [lcm, gcd, gcf, is_prime]

basecalc:
  -as_plugin: 1
  Toolbox::Simple:
    -select: [dec2hex, hex2dec, dec2bin, dec2oct, oct2dec]
  Math::BaseCalc:
    from_base:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
            sub {
            Math::BaseCalc->new(digits => $args->{digits} || $kind_args->{digits})->from_base(shift);
          }
        }
    to_base :
      - |
        sub {
           my($pkg, $class, $func, $args, $kind_args) = @_;
           sub {
              Math::BaseCalc->new(digits => $args->{digits} || $kind_args->{digits})->to_base(shift);
           }
        }
  -usage: |
    =head3 from_base / to_base

      use Util::All -basecalc => [-args => {digits => [0,1]}];
      to_base(4);     # 100
      from_base(100); # 4
 
  -test :
    -
      - package test_basecalc1; use Util::All -basecalc => [-args => {digits => [0,1]}]; (to_base(4), from_base(100));
      - 100, 4
    -
      - package test_basecalc2; use Util::All -basecalc => [to_base => {digits => [0,1], -as => 'to_base2'}]; to_base2(4);
      - 100
    -
      - package test_basecalc3; use Util::All -basecalc => [from_base => {digits => [0,1], -as => 'from_base2'}]; from_base2(100);
      - 4

datetime:
  -require: ['Date::Manip']
  -as_plugin: 1
  -usage: |
    =head3 functions to return DateTime object
    
      $dt = datetime(year => .., month => ..,);
      $dt = datetime_parse("2009/09/09");
      $dt = now;
      $dt = today;
    
    =head3 functions to return DateTime::Duration object
    
    NOTE THAT: end_of_month is set as limit.
      
      year
      month
      day
      hour
      minute
      second
    
    They return DateTime::Duration object. So you can use them for calcuration.
    
      $duration = year + month + day
    
    You can use plural form of these functions, too which can take number.
    
      years 5;
      months 5;

    example:
    
      $after_five_year_from_now = now + years 5;

    =head3 How to change end_of_month?

      use Util::All -datetime => [-args => {end_of_month => 'wrap'}];

  -test:
    - 
      - package test_datetime1; use Util::All '-datetime'; my $dt = datetime_parse("1970/01/01"); $dt += year; $dt->year;
      - 1971
    - 
      - package test_datetime2; use Util::All '-datetime'; my $dt = datetime_parse("1970/01/01"); $dt += years 2; $dt->year;
      - 1972
    - 
      - package test_datetime3; use Util::All '-datetime'; my $dt = datetime_parse("1970/02/01"); $dt += month; $dt->day;
      - 1
    - 
      - package test_datetime4; use Util::All '-datetime'; year->end_of_month_mode;
      - ('limit')
    - 
      - package test_datetime5; use Util::All '-datetime' => [-args => {end_of_month => 'wrap'}]; year->end_of_month_mode;
      - ('wrap')
    - 
      - package test_datetime6; use Util::All '-datetime' => ['month', year => {end_of_month => 'preserve'}]; join ' ', year->end_of_month_mode, month->end_of_month_mode;
      - ('preserve limit')
    - 
      - package test_datetime7; use Util::All '-datetime' => ['year', month => {end_of_month => 'wrap'}]; join ' ', month->end_of_month_mode, year->end_of_month_mode;
      - ('wrap limit')
    - 
      - package test_datetime8; use Util::All '-datetime' => ['day', days => {end_of_month => 'preserve'}]; join ' ', days(5)->end_of_month_mode, day->end_of_month_mode;
      - ('preserve limit')

  DateTime::Duration:
    year   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(years  => 1, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    month  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(months => 1, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    day    : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(days   => 1, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    hour   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(hours  => 1, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    minute : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(minutes => 1, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    second : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(seconds => 1, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    years  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(years  => shift, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    months : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(months => shift, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    days   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(days   => shift, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    hours  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(hours  => shift, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    minutes: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(minutes => shift, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    seconds: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(seconds => shift, end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit") }
      }
    datetime_duration: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub {DateTime::Duration->new(end_of_month => $args->{end_of_month} || $kind_args->{end_of_month} || "limit", @_)}
      }
  Date::Parse:
    datetime_parse: |
      sub {
        my $i = 1;
        if (not $INC{"Date/Manip.pm"}) {
          $i = eval "require Date::Manip" ? 0 : 2;
        }
        if ($i == 2) {
          require DateTime::TimeZone;
          return
            sub {
              my ($ss,$mm,$hh,$day,$month,$year,$zone) = Date::Parse::strptime(@_);
              my $offset = defined $zone ? DateTime::TimeZone->offset_as_string($zone) : 'local';
              DateTime->new(year => $year + 1900, month => ++$month, day => $day,
                hour => $hh || 0, minute => $mm || 0, second => $ss || 0,
                time_zone => $offset);
            }
        } else {
          return
            sub {
              unless ($i) {
                $i = 1;
                Date::Manip::Date_Init();
              }
              my ($ss,$mm,$hh,$day,$month,$year,$zone) = Date::Parse::strptime(@_);
              DateTime->new(year => $year + 1900, month => ++$month, day => $day,
                hour => $hh || 0, minute => $mm || 0, second => $ss || 0,
                time_zone => $Date::Manip::Zone{n2o}->{Time::Zone::tz_name($zone)} || 'local');
            };
        }
      }
  DateTime:
    today   : sub {sub () { DateTime->today(@_) }}
    now     : sub {sub () { DateTime->now(@_) }}
    datetime: sub {sub { DateTime->new(@_) }}

# date: *datetime

benchmark:
  -as_plugin: 1
  Benchmark:
    -select: 
      - timeit
      - timethis
#     - usage:
#        - timethis
#        - timethis($count, \&code)
#        - timethis repeat &code $count times
      - timethese
      - timediff
      - timestr
      - timesum
      - cmpthese
      - countit
    cmpsamearg:
      - | 
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::cmpthese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - usage:
        - cmpsamearg($count, {name => \&code, name2 => \&code}, \%samearg)
        - |
          like cmpthese but compare 2 code with same argument.
          if $count can be negative or 0, it means the number of CPU seconds(0 is regarded as 3).
    timesamearg:
      - |
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::timethese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - usage:
        - timesamearg($count, {name => \&code, name2 => \&code}, \%samearg)
        - |
          like timethese but compare 2 code with same argument.
          if $count can be negative or 0, it means the number of CPU seconds(0 is regarded as 3).

file:
  -as_plugin: 1
  Path::Class:
    -select:
      - file
      - dir
  File::Find:
    find : find_file
  File::Path:
    - make_path
    - remove_tree
  File::Slurp:
    -select   :
      - read_file
      - write_file
    slurp     : slurp_file
  File::Copy:
    copy: copy_file
    move: move_file
  File::Temp:
    tempfile:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
          sub {
            my @args = @_;
            my %args = (%$kind_args, %$args, @args % 2 ? (TEMPLATE => @args) : @args);
            my %new_args = map {uc($_) => $args{$_}} keys %args;
            if (exists $new_args{TEMPLATE}) {
              if ($new_args{TEMPLATE} =~s{(X{4}X*)(.+)?$}{$1} or $new_args{TEMPLATE} =~s{(\*)(.+)?$}{XXXX}) {
                 $new_args{SUFFIX} ||= $2;
              }
              if ($new_args{TEMPLATE} !~ /XXXX$/) {
                $new_args{TEMPLATE} .= "XXXX"
              }
            }
            File::Temp->new(%new_args);
          }
        }
      - usage:
        - |
          $tmpfile = tempfile("anyname*.dat");
          $tmpfile = tempfile("anynameXXXX.dat"); # as same as the above
          $tmpfile = tempfile("anyname*.dat", dir => '/var/tmp');
          $tmpfile = tempfile("anyname*", dir => '/var/tmp', suffix => '.dat', exlock => 0);
          $tmpfile = tempfile(template => "anyname*", dir => '/var/tmp', suffix => '.dat', exlock => 0);
          
          my $filename = $tmpfile->filename;
          print $tmpfile "Test";
        - |
          create temporary file. on BSD derived systems, O_EXLOCK is used(see File::Temp manual).
          If you don't want to lock temporary file, give exlock => 0 for arguments.
      - test:
        - 
          - my $fh = tempfile("anyname*.dat", dir => "./t/data/", unlink => 1); $fh->filename =~m{^t/data/anyname\w{4}\.dat$} || $fh->filename;
          - 1
          - my $fh = tempfile("anyname", dir => "./t/data/", suffix => ".tmp", unlink => 1); $fh->filename =~m{^t/data/anyname\w{4}\.tmp$} || $fh->filename;
          - 1
        - 
          - my $fh = tempfile(template => "anyname", dir => "./t/data/", suffix => ".tmp", unlink => 1); $fh->filename =~m{^t/data/anyname\w{4}\.tmp$} || $fh->filename;
          - 1
        - 
          - my $fh = tempfile("anynameXXXXXXXX", dir => "./t/data/", suffix => ".tmp", unlink => 1); $fh->filename =~m{^t/data/anyname\w{8}\.tmp$} || $fh->filename;
          - 1

# bool:
#   Return::Value:
#     - 'success'
#     - 'failure'
#   -usage: |
#      sub yatta { success("OK") }
#      if (my $r = yatta) {
#         print $r; # "OK";
#      }
#      sub orz { success("NG") }
#      unless (my $r = orz) {
#         print $r; # "NG";
#      }
#   -test:
#     - 
#       - 'success("yatta") ? 1 : 0;'
#       - 1
#     - 
#       - 'failure("orz") ? 1 : 0;'
#       - 0
#     - 
#       - my $x = success("yatta");
#       - ("yatta")
#     - 
#       - my $x = failure("orz");
#       - ("orz")

utime:
  Time::HiRes:
    - usleep
    - nanosleep
    - ualarm

number:
  -as_plugin: 1
  Number::Format:
    number_commify: |
      sub {
        # code is borrowed from Template::Plugin::Comma
        sub {
          local $_ = shift;
          while (s/((?:\A|[^.0-9])[-+]?\d+)(\d{3})/$1,$2/s){}
          return $_;
        }
      }
    number_round: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->round(@_);
        }
      }
    number_format: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_number(@_);
        }
      }
    number_price: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_price(@_);
        }
      }
    number_unit: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_bytes(@_);
        }
      }
    to_number: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->unformat_number(@_);
        }
      }
  -test:
    -
      - number_commify(10000);
      - ('10,000')
    -
      - number_price(10000);
      - Number::Format->new->format_price(10000);
    -
      - number_round(123, -2);
      - 100
    -
      - number_round(123.25, 1);
      - 123.3
    -
      - number_unit(1024, unit => 'K', mode => 'iec')
      - ('1KiB')
    -
      - number_unit(1048576, unit => 'M', mode => 'trad')
      - ('1M')
    -
      - to_number('1,000');
      - 1000
    -
      - to_number('1,025');
      - 1025
    -
      - to_number('1KiB');
      - 1024
image:
  -as_plugin: 1
  -require : ['File::Slurp']
  Imager:
    convert_image:
      - |
        sub {
          sub {
            my ($before, $after) = @_;
            $after ||= '';
            my $img = Imager->new;
            $img->read(file => $before) or die $img->errstr;
            if ($after !~ /\./) {
              my $i;
              $img->write(data => \$i, type => $after) or die $img->errstr;
              print $i;
            } else {
              $img->write(file => $after) or die $img->errstr;
            }
            return $img;
          }
        }
      - usage:
        - |
          convert_image("before.jpg", "after.png");
          convert_image("before.jpg", "png"); # output to stdout as ping
        - convert images to other format.
      - test:
        - 
          - use Util::All -image; convert_image("t/data/perl.jpg", "t/data/perl.png"); my $type = image_type("t/data/perl.png");
          - '"PNG"'
        - 
          -  use Util::All -image; my $info = image_info("t/data/perl.png"); ($info->{width}, $info->{height});
          - (100, 100)
        - 
          -  use Util::All -image; resize_image("t/data/perl.png", "t/data/perl_mini.png", 0.5); my $info = image_info("t/data/perl_mini.png"); ($info->{width}, $info->{height});
          - (50, 50)
        - 
          -  use Util::All -image; resize_image("t/data/perl.png", "t/data/perl_wide.png", [200,100]); my $info = image_info("t/data/perl_wide.png"); ($info->{width}, $info->{height});
          - (200, 100)
    resize_image:
      - |
        sub {
          sub ($@){
            my ($before, $after, @conf) = @_;
            $after ||= '';
            my $img = Imager->new;
            $img->read(file => $before) or die $img->errstr;
            my %conf;
            if (ref $conf[0] eq 'ARRAY') {
              $conf{xpixels} = $conf[0]->[0];
              $conf{ypixels} = $conf[0]->[1];
              $conf{type} = 'nonprop';
            } elsif(@conf == 1 and not ref $conf[0]) {
              $conf{scalefactor} = $conf[0];
            } else {
                %conf = @conf;
            }
            my $newimg = $img->scale(%conf);
            if ($after !~ /\./) {
              my $i;
              $newimg->write(data => \$i, type => $after) or die $newimg->errstr;
              print $i;
            } else {
              $newimg->write(file => $after) or die $newimg->errstr;
            }
            return $newimg;
          }
        }
      - usage:
        - |
          resize_image("before.jpg", "after.png", %option);
          resize_image("before.jpg", "after.png", [200, 100]); # 200x100px
          resize_image("before.jpg", "after.png", 0.5); # 1/2 scale
          resize_image("before.jpg", "png", 0.5);  # output 1/2 scale image to STDOUT as ping
        - |
          resize image.
  Image::Info:
    image_info:
      - |
        sub {
          sub {
            my ($file) = @_;
            my $info = Image::Info::image_info($file);
            if (ref $info eq 'HASH' and exists $info->{error}) {
              die $info->{error};
            }
            return $info
          }
        }
      - usage:
        - my $info = image_info("picture.jpg");
        - return image information(Image::Info)
    image_type:
      - |
        sub {
          sub {
            my ($file) = @_;
            my $type = Image::Info::image_type($file);
            if (exists $type->{error}) {
              die $type->{error};
            }
            return $type->{file_type};
          }
        }
      - usage:
        - my $info = image_type("picture.jpg");
        - return image type(Image::Info)

exception:
  -as_plugin: 1
  Try::Tiny:
    - try
    - catch

csv:
  -as_plugin: 1
  Text::CSV:
    parse_csv:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          $args ||= {};
          $kind_args ||= {};
          use strict;
          if (not defined &Util::All::_Tmp::Text::CSV::next) {
            no strict 'refs';
            *{"Util::All::_Tmp::Text::CSV::next"} = sub { my $self = shift; my $r; $r = $self->{sub}->() or (!$self->{pass_fh} and close $self->{fh}); return $r}
          }
          sub {
            my $pass_fh = 0;
            my ($fh, $column_names) = @_;
            my $csv = Text::CSV->new({binary => 1, %$kind_args, %$args});
            unless (ref $fh) {
              my $file = $fh;
              undef $fh;
              open($fh, '<', $file) or Carp::croak("cannot open file: $file");
            } else {
              $pass_fh = 1;
            }
            my $sub;
            if (@_ == 2) {
              $csv->column_names($column_names);
              $sub = sub {$csv->getline_hr($fh)};
            } else {
              $sub = sub {$csv->getline($fh)};
            }
            return bless {sub => $sub, fh => $fh, pass_fh => $pass_fh} => "Util::All::_Tmp::Text::CSV";
          }
        }
      - usage:
        - |
          use Util::All -csv;
          
          my $csv = parse_csv($file_or_fh);
          while (my $ar = $csv->next) {
             print "@$ar\n";
          }
          
          my $csv = parse_csv($file_or_fh, ['name', 'age']);
          while (my $hr = $csv->next) {
             print join " ", %$hr, "\n";
          }
          
          # pass options to Text::CSV
          use Util::All -csv => [-args => {binary => 0, eol => "\r\n"}];
  -test:
    -
      - package test_csv1; use Util::All -csv; my $csv = parse_csv("t/data/test.csv"); my $sum = 0; while (my $l = $csv->next) {$sum +=$l->[1]}; $sum;
      - 223
    -
      - package test_csv2; use Util::All -csv; my $csv = parse_csv("t/data/test.csv", ['l', 'num']); my $label = ''; while (my $l = $csv->next) {$label .=$l->{l}}; $label;
      - '"abcdefアイウエオ"'
    -
      - package test_csv3; use Util::All -csv; open my $fh, "t/data/test.csv"; my $csv = parse_csv($fh); my $sum = 0; while (my $l = $csv->next) {$sum +=$l->[1]}; $sum;
      - 223
    -
      - package test_csv4; use Util::All -csv; open my $fh, "t/data/test.csv"; my $csv = parse_csv($fh); 1 while $csv->next; tell $fh;
      - 49

storable:
  -as_plugin: 1
  Storable:
    thaw:
      -  sub {sub {Storable::thaw(@_)}}
      - usage:
        - $data = thaw($storable_data);
        - retrieve data from stroable.
    freeze:
      -  sub {sub {Storable::freeze(@_)}}
      - usage:
        - $storable_data = freeze($data);
        - serialize $storable_data
  -test:
    -
      - thaw(freeze({a => 1}))->{a}
      - 1
    -
      - thaw(freeze({a => 123}))->{a}
      - 123
    -
      - use Util::All -base64; thaw(base64_decode('BAcIMTIzNDU2NzgECAgIAwEAAAAI5AEAAABi'))->{b};
      - 100

serialize:
  -as_plugin: 1
  Data::Serializer:
    serialize:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $ds;
          $ds = Data::Serializer->new(%$kind_args, %$args) if (%$kind_args or %$args);
          sub {
            my ($data, $opt) = @_;
            unless ($opt) {
              $ds->serialize($data);
            } else {
              my $ds =  Data::Serializer->new(%$opt);
              $ds->serialize($data);
            }
          }
        }
    deserialize:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $ds;
          $ds = Data::Serializer->new(%$kind_args, %$args) if (%$kind_args or %$args);
          sub {
            my ($serialized_data, $opt) = @_;
            unless ($opt) {
              $ds->deserialize($serialized_data);
            } else {
              my $ds =  Data::Serializer->new(%$opt);
              $ds->deserialize($serialized_data);
            }
          }
        }
  -usage: |
      =head3 serialize / deserialize
      
      serialize data usign L<Data::Serializer>.

        use Util::All -serialize => [-args => {serializer => 'Storable', digester => 'MD5', cipher => 'DES', secret => 'my secret', compress => 1}];
        my $serialized_data   = serialize({a => 123,  b => 223});
        my $deserialized_data = deserialize($data);

        my $serialized_data   = serialize({a => 123,  b => 223}, {serializer => 'Storable', digester => 'MD5', cipher => 'DES', secret => 'my secret', compress => 1});
        my $deserialized_data = deserialize($data, {serializer => 'Storable', digester => 'MD5', cipher => 'DES', secret => 'my secret', compress => 1});
  -test:
    -
      - "package Hoge1; use Util::All -serialize => [-args => {serializer => 'Storable', digester => 'MD5', cipher => 'DES', secret => 'my secret', compress => 1}]; my $serialized_data = serialize({a => 123,  b => 223}); deserialize($serialized_data);"
      - '{a => 123, b => 223}'
    - 
      - "package Hoge2; use Util::All -serialize; my $opt = {serializer => 'Storable', digester => 'MD5', cipher => 'DES', secret => 'my secret', compress => 1}; my $serialized_data = serialize({a => 123,  b => 223}, $opt); deserialize($serialized_data, $opt);"
      - '{a => 123, b => 223}'

prompt:
  -as_plugin: 1
  IO::Prompt:
    -select:
      - prompt
    required_prompt:
      - |
        sub {
          sub {
            my $message = shift;
            my $answer;
          PROMPT:
            {
              $answer = IO::Prompt::prompt($message, @_);
              $answer->{value} or redo PROMPT;
              return $answer->{value};
            }
          }
        }
    password_prompt:
      - |
        sub {
          sub {
            my $message = shift;
            my $answer;
            $answer = IO::Prompt::prompt($message, -echo => "*", @_);
            $answer->{value};
          }
        }
  -test:
    - skip: $ENV{HARNESS_ACTIVE} or $^O eq 'MSWin32';
    -
      - $|=1; my $answer = required_prompt("input somthing(1):"); $answer !~ /%$/;
      - 1;
    -
      - $|=1; password_prompt("input somthing(2):"); my $answer = required_prompt("\ninputted value was displaied as '*' ?(y/n)", -yn); $answer eq 'y';
      - 1;
