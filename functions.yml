---
scalar:
  Scalar::Util:
    - blessed
    - dualvar
    - isvstring
    - isweak
    - looks_like_number
    - openhandle
    - readonly
    - refaddr
    - reftype
    - set_prototype
    - tainted
    - weaken

list:
  List::Util:
    - first
    - max
    - maxstr
    - min
    - minstr
    - reduce
    - shuffle
    - sum
  List::MoreUtils:
    - after
    - after_incl
    - all
    - any
    - apply
    - before
    - before_incl
    - each_array
    - each_arrayref
    - false
    - first_index
    - first_value
    - firstidx
    - firstval
    - indexes
    - insert_after
    - insert_after_string
    - last_index
    - last_value
    - lastidx
    - lastval
    - mesh
    - minmax
    - natatime
    - none
    - notall
    - pairwise
    - part
    - true
    - uniq
    - zip

hash:
  Hash::Util:
    -select:
     - hash_seed
     - lock_hash
     - lock_keys
     - lock_value
     - unlock_hash
     - unlock_keys
     - unlock_value
  Tie::IxHash:
    indexed:
      - |
        sub {
          sub (\%@) {
            my $hash = shift;
            tie %$hash, "Tie::IxHash";
            %$hash = @_;
          }
        }
      - usage:
        - indexed my %hash = (a => 1, b => 2);
        - '%hash is indexed.'
      - test:
        -
          - indexed my %hash; %hash = qw/5 1 4 2 3 3 2 4 1 5 0 6/;  keys %hash
          - qw/5 4 3 2 1 0/
debug:
  -require: ['B::Deparse']
  Data::Dumper:
    Dumper:
      - dumper
      - usage:
        - dumper(@variables)
        - Dumper in L<Data::Dumper>.
    code_dumper:
      - sub {sub(&) { local $Data::Dumper::Deparse = 1; Data::Dumper::Dumper(@_)} }
      - usage:
        - code_dumper(sub { print "hello World" })
        - dump code reference as string. 
  Data::Dump:
    -select: 
      - dump
      - usage:
        - 
          - print dump(@vars);
          - dump(@vars);
        - |
          dump of L<Data::Dumper>. 
          dump strucutre. In later case, result is dumped to STDERR.
      - pp
      - usage:
        - pp("{ x => 1, y => 2, z => 3}");
        - dump after given string is evaled.
      - dd
      - usage:
        - dd(@vars);
        - as same as dump but output to STDOUT.
      - ddx
      - usage:
        - dd(@vars);
        - as same as dd but output to STDOUT with line number.
    p:
      - sub { sub(@) { Data::Dump::dump(@_) } }
      - p($variable)
      - as same as dump(function name is borrowed from Ruby).
    dump_code:
      - |
        sub {
           sub(&) {
            if (wantarray) {
              local $Data::Dumper::Deparse = 1; Data::Dumper::Dumper(@_)
            } else {
              print STDERR Data::Dumper::Dumper(@_);
            }
          }
        }
      - usage:
        - dump_code( sub { ... } );
        - dump code reference as string. 
  Tie::Trace:
    -select: ['watch']

string:
  String::Util:
    -select:
      - crunch
      - define
      - equndef
      - fullchomp
      - hascontent
      - htmlesc
      - neundef
      - nospace
      - randcrypt
      - randword
      - trim
      - unquote
    strings: |
      sub {
        sub {
          my $str = shift;
          $str =~ s/\p{Cc}//g;
          return $str;
        }
      }
  String::CamelCase:
    - camelize
    - decamelize
    - wordsplit
  -test:
    -
      - package test_strings1; use Util::All -string; strings('111' . "\0" . '111');
      - '"111111"'

md5:
  Digest::MD5:
    - md5
    - md5_hex
    - md5_base64
sha:
  Digest::SHA:
    - sha1
    - sha1_hex
    - sha1_base64
    - sha256
    - sha256_hex
    - sha256_base64
    - sha384
    - sha384_hex
    - sha384_base64
    - sha512
    - sha512_hex
    - sha512_base64

utf8:
  utf8:
    is_utf8  : is_utf8
    upgrade  : utf8_upgrade
    downgrade: utf8_downgrade
    encode   : utf8_encode
  Data::Visitor::Encode:
    utf8_on  :
      - sub {sub {Data::Visitor::Encode->new->utf8_on(@_)}}
      - utf8_on($data)
      - recursively make utf8 flag on
    utf8_off :
      - sub {sub {Data::Visitor::Encode->new->utf8_off(@_)}}
      - utf8_off($data)
      - recursively make utf8 flag off

cgi:
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape
  HTML::Entities:
    decode_entities: html_entity_decode
    encode_entities: html_entity_encode

html:
  HTML::Entities:
    decode_entities: html_entity_decode
    encode_entities: html_entity_encode
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape

xml:
  -require: ['XML::Parser']
  -as_plugin: 1
  XML::Simple:
    from_xml: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        local $XML::Simple::XML_SIMPLE_PREFERRED_PARSER = $kind_args->{parser} || $args->{parser} || 'XML::Parser';
        $args->{Forcearray} ||= $kind_args->{force_array} || $args->{force_array};
        $args->{KeyAttr}    ||= $kind_args->{key_attr} || $args->{key_attr};
        sub {
          XML::Simple::XMLin(shift, %$args);
        }
      }
    to_xml: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        $args->{KeyAttr} ||= $kind_args->{key_attr} || $args->{key_attr};
        sub {
          XML::Simple::XMLout(shift, %$args);
        }
      }

char_encode:
  Encode:
    encode: char_encode
    decode: char_decode
    char_convert:
      - |
        sub {
           my ($pkg, $class, $func, $args) = @_;
           my $g_class = 0;
           if (exists $args->{guess}){
             require Encode::Guess;
             Encode::Guess->import(@{$args->{guess}});
           } elsif (not $INC{"Encode/Detect.pm"} and not $INC{"Encode/Guess.pm"}) {
             eval {require Encode::Detect; $g_class = 1} or require Encode::Guess;
           }
           sub {
             my ($str, $to, $from) = @_;
             Encode::from_to(shift, $from ? $from : $g_class ? "DETECT" : "GUESS", $to);
           }
        }
      - usage:
        -
          - char_convert($str, "euc-jp"); # to euc-jp
          - char_convert($str, "euc-jp", "sjis"); # to euc-jp from sjis
        - |
           convert $str to second argument charset. third argument is charset of $str.
           when third argument is omitted, Encode::Detect(if installed) or Encode::Guess is used.
    from_to: char_from_to
  -test:
    - 
      - char_convert(my $s = "あ", "euc-jp"); $s
      - my $s = "あ"; Encode::from_to($s, "utf8", "euc-jp"); $s;
    - 
      - char_convert(my $s = "あ", "cp932", "utf8"); $s
      - my $s = "あ"; Encode::from_to($s, "utf8", "cp932"); $s;


uri:
  URI::Escape:
    - uri_escape
    - uri_unescape
  URI::Split:
    - uri_split
    - uri_join
  URI:
    uri_make:
      - |
        sub {
          sub {
            use utf8;
            my ($url, $form) = @_;
            my %form;
            foreach my $k (keys %$form) {
              my ($key, $value) = ($k, $form->{$k});
              utf8::decode($key)   unless utf8::is_utf8($k);
              utf8::decode($value) unless utf8::is_utf8($value);
              $form{$key} = $value;
            }
            my $u = URI->new($url);
            $u->query_form(%form);
            $u->as_string;
          }
        }
      - test:
        - 
          - uri_make('http://example.com/', { foo => "あ", bar => "い"});
          - ('http://example.com/?bar=%E3%81%84&foo=%E3%81%82')
        - 
          - my $x = "あ"; utf8::decode($x); uri_make('http://example.com/', { foo => $x});
          - ('http://example.com/?foo=%E3%81%82')
base64:
  MIME::Base64:
    encode_base64: base64_encode
    decode_base64: base64_decode
  MIME::Base64::URLSafe:
    urlsafe_b64encode: urlsafe_base64_encode
    urlsafe_b64decode: urlsafe_base64_decode

http:
  -require : ['LWP::UserAgent']
  -usage : |
      =head3 http_* functions
      
      do http method and get HTTP::Response object.
      
        http_get($url, \%query);
        http_post($url, \%query);
        http_put($url, \%query);
        http_delete($url, \%query);
        http_head($url, \%query);
  HTTP::Request::Common:
    http_put   : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::PUT(@_)) } }
    http_delete: sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::DELETE(@_)) } }
    http_head  : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::HEAD(@_)) } }
# If you cannot install WWW::Curl::Simple, use the following
#    http_get   : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::GET(@_)) } }
#    http_post  : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::POST(@_)) } }
  WWW::Curl::Simple:
    http_get   : sub { require WWW::Curl::Simple; my $ua = WWW::Curl::Simple->new(); sub { $ua->get(@_) } }
    http_post  : sub { require WWW::Curl::Simple; my $ua = WWW::Curl::Simple->new(); sub { $ua->post(@_) } }


mail:
  Mail::Sendmail:
    send_mail: |
      sub {
        sub {
          my (%args) = @_;
          my %new;
          $new{ucfirst $_} = $args{$_} for keys %args;
          Mail::Sendmail::sendmail(%new);
          # error $Mail::Sendmail::error;
          # log   $Mail::Sendmail::log;
        }
      }
  Email::MIME:
     parse_mail: |
       sub {
         sub {my $message = Email::MIME->new(@_)}
       }
 # Email::Sender:
 # Email::MIME::Creator:

carp:
  Carp:
    - croak
    - cluck
    - carp
    - confess
    - shortmess
    - longmess

yaml: &yaml
  -require: ['File::Slurp']
  YAML::XS:
    Load: from_yaml
    Dump: to_yaml
    from_yaml_file:
      - sub {require File::Slurp; sub ($) { YAML::XS::Load(scalar File::Slurp::slurp(shift)) }}
      - from_yaml_file($yaml_file);
      - load YAML data from file
    to_yaml_file:
      - sub {require File::Slurp; sub { File::Slurp::write_file(shift, YAML::XS::Dump(shift))}}
      - to_yaml_file($yaml_file);
      - dump YAML data to file
  -test:
    -
      - package test_yaml; use Util::All -yaml, -debug; dump from_yaml(to_yaml({hoge => 1}));
      - "'{ hoge => 1 }'"
    - 
      - package test_yaml; use Util::All -yaml; to_yaml(from_yaml_file("t/data/test.yml"));
      - '"---\nhoge: 1\n"'

# yml: *yaml

json:
  -require: ['File::Slurp']
  JSON::XS:
    decode_json: from_json
    encode_json: to_json
    from_json_file:
      - sub {require File::Slurp; sub ($) { JSON::XS::decode_json(scalar File::Slurp::slurp(shift)) }}
      - from_json_file($json_file);
      - load JSON data from file
    to_json_file:
      - sub {require File::Slurp; sub { File::Slurp::write_file(shift, JSON::XS::encode_json(shift))}}
      - from_json_file($json_file);
      - load JSON data from file
  -test:
    -
      - package test_json; use Util::All -json, -debug; dump from_json(to_json({hoge => 1}));
      - "'{ hoge => 1 }'"
    - 
      - package test_json; use Util::All -json; to_json(from_json_file("t/data/test.json"));
      - 'qq{{"hoge":1}}'

basecalc:
  Math::BaseCalc:
    from_base:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
            sub {
            Math::BaseCalc->new(digits => $kind_args->{digits} || $args->{digits})->from_base(shift);
          }
        }
    to_base :
      - |
        sub {
           my($pkg, $class, $func, $args, $kind_args) = @_;
           sub {
              Math::BaseCalc->new(digits => $kind_args->{digits} || $args->{digits})->to_base(shift);
           }
        }
  -test :
    -
      - package test_basecalc1; use Util::All -basecalc => {-args => {digits => [0,1]}}; (to_base(4), from_base(100));
      - 100, 4
    -
      - package test_basecalc2; use Util::All -basecalc => [to_base => {digits => [0,1], -as => 'to_base2'}]; to_base2(4);
      - 100
    -
      - package test_basecalc3; use Util::All -basecalc => [from_base => {digits => [0,1], -as => 'from_base2'}]; from_base2(100);
      - 4

datetime: &datetime
  -require: ['Date::Manip']
  -as_plugin: 1
  -usage: |
    =head3 functions to return DateTime object
    
      $dt = datetime(year => .., month => ..,);
      $dt = datetime_parse("2009/09/09");
      $dt = now;
      $dt = today;
    
    =head3 functions to return DateTime::Duration object
    
    NOTE THAT: end_of_month is set as limit.
      
      year
      month
      day
      hour
      minute
      second
    
    They return DateTime::Duration object. So you can use them for calcuration.
    
      $duration = year + month + day
    
    You can use plural form of these functions, too which can take number.
    
      years 5;
      months 5;

    example:
    
      $after_five_year_from_now = now + years 5;

  DateTime::Duration:
    year   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(years  => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    month  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(months => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    day    : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(days   => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    hour   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(hours  => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    minute : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(minutes => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    second : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(seconds => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    years  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(years  => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    months : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(months => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    days   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(days   => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    hours  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(hours  => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    minutes: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(minutes => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    seconds: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(seconds => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    datetime_duration: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub {DateTime::Duration->new(end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit", @_)}
      }
  Date::Parse:
    datetime_parse: |
      sub {
        my $i = 1;
        unless ($INC{"Date/Manip.pm"}) {
          require Date::Manip;
          $i = 0;
        }
        sub {
          unless ($i) {
            $i = 1;
            Date::Manip::Date_Init();
          }
          my ($ss,$mm,$hh,$day,$month,$year,$zone) = Date::Parse::strptime(@_);
          DateTime->new(year => $year + 1900, month => ++$month, day => $day,
            hour => $hh || 0, minute => $mm || 0, second => $ss || 0,
            time_zone => $Date::Manip::Zone{n2o}->{Time::Zone::tz_name($zone)});
        }
      }
  DateTime:
    today   : sub {sub () { DateTime->today(@_) }}
    now     : sub {sub () { DateTime->now(@_) }}
    datetime: sub {sub { DateTime->new(@_) }}

# date: *datetime

benchmark:
  Benchmark:
    -select: 
      - timeit
      - timethis
#     - usage:
#        - timethis
#        - timethis($count, \&code)
#        - timethis repeat &code $count times
      - timethese
      - timediff
      - timestr
      - timesum
      - cmpthese
      - countit
    cmpsamearg:
      - | 
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::cmpthese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - usage:
        - cmpsamearg($count, {name => \&code, name2 => \&code}, \%samearg)
        - like cmpthese but compare 2 code with same argument
    timesamearg:
      - |
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::timethese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - usage:
        - timesamearg($count, {name => \&code, name2 => \&code}, \%samearg)
        - like timethese but compare 2 code with same argument

file:
  File::Find:
    find : find_file
  File::Path:
    - make_path
    - remove_tree
  File::Slurp:
    -select   :
      - read_file
      - write_file
    slurp     : slurp_file
  File::Copy:
    copy: copy_file
    move: move_file
  File::Temp:
    tempfile:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
          sub {
            my @args = @_;
            my %args = (%$kind_args, %$args, @args % 2 ? (TEMPLATE => shift @args) : @args);
            my %new_args = map {uc($_) => $args{$_}} keys %args;
            if (exists $new_args{TEMPLATE}) {
              if ($new_args{TEMPLATE} =~s{\*(.+)$}{XXXX}) {
                 $new_args{SUFFIX} = $1;
              }
              if ($new_args{TEMPLATE} !~ /XXXX$/) {
                $new_args{TEMPLATE} .= "XXXX"
              }
            }
            File::Temp->new(%new_args);
          }
        }
      - usage:
        - |
          tempfile("anyname*.dat")
          tempfile("anyname*.dat", dir => '/var/tmp')
          tempfile("anyname*", dir => '/var/tmp', suffix => '.dat', exlock => 1)
    locked_tempfile:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
          # %args = map {uc($_) => $args->{$_}} keys %$args;
          # %kind_args = map {uc($_) => $args->{$_}} keys %$kind_args;
          sub {
            my @args = @_;
            my %args = (%$kind_args, %$args, @args % 2 ? (TEMPLATE => shift @args) : @args);
            my %new_args = map {uc($_) => $args{$_}} keys %args;
            if (exists $new_args{TEMPLATE}) {
              if ($new_args{TEMPLATE} =~s{\*(.+)$}{XXXX}) {
                 $new_args{SUFFIX} = $1;
              }
              if ($new_args{TEMPLATE} !~ /XXXX$/) {
                $new_args{TEMPLATE} .= "XXXX"
              }
            }
            File::Temp->new(%new_args, EXLOCK => 1);
          }
        }

bool:
  Return::Value:
    - 'success'
    - 'failure'
  -usage: |
     sub yatta { success("OK") }
     if (my $r = yatta) {
        print $r; # "OK";
     }
     sub orz { success("NG") }
     unless (my $r = orz) {
        print $r; # "NG";
     }
  -test:
    - 
      - 'success("yatta") ? 1 : 0;'
      - 1
    - 
      - 'failure("orz") ? 1 : 0;'
      - 0
    - 
      - my $x = success("yatta");
      - ("yatta")
    - 
      - my $x = failure("orz");
      - ("orz")

time:
  Time::HiRes:
    - usleep
    - nanosleep
    - ualarm

number:
  -as_plugin: 1
  Number::Format:
    number_commify: |
      sub {
        # code is borrowed from Template::Plugin::Comma
        sub {
          local $_ = shift;
          while (s/((?:\A|[^.0-9])[-+]?\d+)(\d{3})/$1,$2/s){}
          return $_;
        }
      }
    number_round: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args);
        sub {
          $n->round(@_);
        }
      }
    number_format: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_number(@_);
        }
      }
    number_price: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_price(@_);
        }
      }
    number_unit: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_bytes(@_);
        }
      }
    to_number: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->unformat_number(@_);
        }
      }
  -test:
    -
      - number_commify(10000);
      - ('10,000')
    -
      - number_price(10000);
      - Number::Format->new->format_price(10000);
    -
      - number_round(123, -2);
      - 100
    -
      - number_round(123.25, 1);
      - 123.3
    -
      - number_unit(1024, unit => 'K', mode => 'iec')
      - ('1KiB')
    -
      - number_unit(1048576, unit => 'M', mode => 'trad')
      - ('1M')
    -
      - to_number('1,000');
      - 1000
    -
      - to_number('1,025');
      - 1025
    -
      - to_number('1KiB');
      - 1024
image:
  -as_plugin: 1
  -require : ['MIME::Base64', 'File::Slurp']
  Imager:
    convert_image:
      - |
        sub {
          sub {
            my ($before, $after) = @_;
            $after ||= '';
            my $img = Imager->new;
            $img->read(file => $before) or die $img->errstr;
            if ($after !~ /\./) {
              my $i;
              $img->write(data => \$i, type => $after) or die $img->errstr;
              print $i;
            } else {
              $img->write(file => $after) or die $img->errstr;
            }
            return $img;
          }
        }
      - usage:
        - |
          convert_image("before.jpg", "after.png");
          convert_image("before.jpg", "png"); # output to stdout as ping
        - convert images to other format.
    resize_image:
      - |
        sub {
          sub ($@){
            my ($before, $after, @conf) = @_;
            $after ||= '';
            my $img = Imager->new;
            $img->read(file => $before) or die $img->errstr;
            my %conf;
            if (ref $conf[0] eq 'ARRAY') {
              $conf{xpixels} = $conf[0]->[0];
              $conf{ypixels} = $conf[0]->[1];
              $conf{type} = 'nonprop';
            } elsif(@conf == 1 and not ref $conf[0]) {
              $conf{scalefactor} = $conf[0];
            } else {
                %conf = @conf;
            }
            my $newimg = $img->scale(%conf);
            if ($after !~ /\./) {
              my $i;
              $newimg->write(data => \$i, type => $after) or die $newimg->errstr;
              print $i;
            } else {
              $newimg->write(file => $after) or die $newimg->errstr;
            }
            return $newimg;
          }
        }
      - usage:
        - |
          resize_image("before.jpg", "after.png", %option);
          resize_image("before.jpg", "after.png", [200, 100]); # 200x100px
          resize_image("before.jpg", "after.png", 0.5); # 1/2 scale
          resize_image("before.jpg", "png", 0.5);  # output 1/2 scale image to STDOUT as ping
        - |
          resize image.
  Image::Info:
    image_info:
      - |
        sub {
          sub {
            my ($file) = @_;
            my $info = Image::Info::image_info($file);
            if (ref $info eq 'HASH' and exists $info->{error}) {
              die $info->{error};
            }
            return $info
          }
        }
      - usage:
        - my $info = image_info("picture.jpg");
        - return image information(Image::Info)
    image_type:
      - |
        sub {
          sub {
            my ($file) = @_;
            my $type = Image::Info::image_type($file);
            if (exists $type->{error}) {
              die $type->{error};
            }
            return $type->{file_type};
          }
        }
      - usage:
        - my $info = image_type("picture.jpg");
        - return image type(Image::Info)
    image_base64:
        - |
         sub {
           require File::Slurp;
           require MIME::Base64;
           sub {
             my ($file) = @_;
             my $d = File::Slurp::slurp($file);
             return MIME::Base64::encode_base64($d);
           }
         }
exception:
  Try::Tiny:
    - try
    - catch

csv:
  -as_plugin: 1
  Text::CSV_XS:
    parse_csv:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          $args ||= {};
          $kind_args ||= {};
          use strict;
          if (not defined &Util::All::Text::CSV_XS::next) {
            no strict 'refs';
            *{"Util::All::_Tmp::Text::CSV_XS::next"} = sub { my $self = shift; my $r; $r = $self->{sub}->() or (!$self->{pass_fh} and close $self->{fh}); return $r}
          }
          sub {
            my $pass_fh = 0;
            my ($fh, $column_names) = @_;
            my $csv = Text::CSV_XS->new({binary => 1, %$kind_args, %$args});
            unless (ref $fh) {
              my $file = $fh;
              undef $fh;
              open($fh, '<', $file) or Carp::croak("cannot open file: $file");
            } else {
              $pass_fh = 1;
            }
            my $sub;
            if (@_ == 2) {
              $csv->column_names($column_names);
              $sub = sub {$csv->getline_hr($fh)};
            } else {
              $sub = sub {$csv->getline($fh)};
            }
            return bless {sub => $sub, fh => $fh, pass_fh => $pass_fh} => "Util::All::_Tmp::Text::CSV_XS";
          }
        }
      - usage:
        - |
          use Util::All -csv;
          
          my $csv = parse_csv($file_or_fh);
          while (my $ar = $csv->next) {
             print "@$ar\n";
          }
          
          my $csv = parse_csv($file_or_fh, ['name', 'age']);
          while (my $hr = $csv->next) {
             print jion " ", %$hr, "\n";
          }
          
          # pass options to Text::CSV_XS
          use Util::All -csv => {-args => {binary => 0, eol => "\r\n"}};
  -test:
    -
      - package test_csv1; use Util::All -csv; my $csv = parse_csv("t/data/test.csv"); my $sum = 0; while (my $l = $csv->next) {$sum +=$l->[1]}; $sum;
      - 223
    -
      - package test_csv2; use Util::All -csv; my $csv = parse_csv("t/data/test.csv", ['l', 'num']); my $label = ''; while (my $l = $csv->next) {$label .=$l->{l}}; $label;
      - '"abcdef"'
    -
      - package test_csv3; use Util::All -csv; open my $fh, "t/data/test.csv"; my $csv = parse_csv($fh); my $sum = 0; while (my $l = $csv->next) {$sum +=$l->[1]}; $sum;
      - 223
    -
      - package test_csv4; use Util::All -csv; open my $fh, "t/data/test.csv"; my $csv = parse_csv($fh); 1 while $csv->next; tell $fh;
      - 30

