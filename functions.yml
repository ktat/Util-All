---
scalar:
  Scalar::Util:
    - blessed
    - dualvar
    - isvstring
    - isweak
    - looks_like_number
    - openhandle
    - readonly
    - refaddr
    - reftype
    - set_prototype
    - tainted
    - weaken

list:
  List::Util:
    - first
    - max
    - maxstr
    - min
    - minstr
    - reduce
    - shuffle
    - sum
  List::MoreUtils:
    - after
    - after_incl
    - all
    - any
    - apply
    - before
    - before_incl
    - each_array
    - each_arrayref
    - false
    - first_index
    - first_value
    - firstidx
    - firstval
    - indexes
    - insert_after
    - insert_after_string
    - last_index
    - last_value
    - lastidx
    - lastval
    - mesh
    - minmax
    - natatime
    - none
    - notall
    - pairwise
    - part
    - true
    - uniq
    - zip

hash:
  Hash::Util:
    -select:
     - hash_seed
     - lock_hash
     - lock_keys
     - lock_value
     - unlock_hash
     - unlock_keys
     - unlock_value
  Tie::IxHash:
    indexed:
      - |
        sub {
          sub (\%@) {
            my $hash = shift;
            tie %$hash, "Tie::IxHash";
            %$hash = @_;
          }
        }
      - indexed my %hash = (a => 1, b => 2);
      - %hash is indexed.

debug:
  Data::Dumper:
    Dumper:
      - dumper
      - ''
      - Dumper in Data::Dumper.
    deparse:
      - sub {sub(&) { local $Data::Dumper::Deparse = 1; Data::Dumper::Dumper(@_)} }
      - deparse(sub { print "hello World" })
      - dump code reference as string. 
  Data::Dump:
    -select: [dump]
    p   :
      - sub { sub { Data::Dump::dump(@_) } }
      - p($variable)
      - as same as dumper(function name is as same as one in Ruby).

string:
  String::Util:
    - crunch
    - define
    - equndef
    - fullchomp
    - hascontent
    - htmlesc
    - neundef
    - nospace
    - randcrypt
    - randword
    - trim
    - unquote
  String::CamelCase:
    - camelize
    - decamelize
    - wordsplit

md5:
  Digest::MD5:
    - md5
    - md5_hex
    - md5_base64
sha:
  Digest::SHA:
    - sha1
    - sha1_hex
    - sha1_base64
    - sha256
    - sha256_hex
    - sha256_base64
    - sha384
    - sha384_hex
    - sha384_base64
    - sha512
    - sha512_hex
    - sha512_base64

utf8:
  utf8:
    is_utf8  : is_utf8
    upgrade  : utf8_upgrade
    downgrade: utf8_downgrade
    encode   : utf8_encode

cgi:
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape
  HTML::Entities:
    decode_entities: html_entity_decode
    encode_entities: html_entity_encode

html:
  HTML::Entities:
    decode_entities: html_entity_decode
    encode_entities: html_entity_encode
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape

xml:
  -require: ['XML::Parser']
  -as_plugin: 1
  XML::Simple:
    xml_load: |
      sub {
        my ($pkg, $class, $func, $args) = @_;
        local $XML::Simple::XML_SIMPLE_PREFERRED_PARSER = $args->{parser} || 'XML::Parser';
        $args->{Forcearray} ||= $args->{force_array};
        $args->{KeyAttr}    ||= $args->{key_attr};
        sub {
          XML::Simple::XMLin(shift, %$args);
        }
      }
    xml_dump: |
      sub {
        my ($pkg, $class, $func, $args) = @_;
        $args->{KeyAttr} ||= $args->{key_attr};
        sub {
          XML::Simple::XMLout(shift, %$args);
        }
      }

char_enc:
  Encode:
    encode: char_encode
    decode: char_decode
    char_convert: |
      sub {
         my ($pkg, $class, $func, $args) = @_;
         my $g_class = 0;
         if (exists $args->{guess}){
           require Encode::Guess;
           Encode::Guess->import(@{$args->{guess}});
         } elsif (not $INC{"Encode/Detect.pm"} and not $INC{"Encode/Guess.pm"}) {
           eval {require Encode::Detect; $g_class = 1} or require Encode::Guess;
         }
         sub {
           my ($str, $to, $from) = @_;
           Encode::from_to(shift, $from ? $from : $g_class ? "DETECT" : "GUESS", $to);
         }
      }
    from_to: char_from_to

uri:
  URI::Escape:
    - uri_escape
    - uri_unescape
  URI::Split:
    - uri_split
    - uri_join
  URI:
    uri_make: |
      sub {
        sub {
          use utf8;
          my ($url, $form) = @_;
          my %form;
          foreach my $k (keys %$form) {
            my ($key, $value) = ($k, $form->{$k});
            utf8::decode($key)   unless utf8::is_utf8($k);
            utf8::decode($value) unless utf8::is_utf8($value);
            $form{$key} = $value;
          }
          my $u = URI->new($url);
          $u->query_form(%form);
          $u->as_string;
        }
      }

base64:
  MIME::Base64:
    encode_base64: base64_encode
    decode_base64: base64_decode

http:
  -require : ['LWP::UserAgent', 'WWW::Curl::Simple']
  -usage : |
      do http method and get HTTP::Response object.
      
        http_get($url, \%query);
        http_post($url, \%query);
        http_put($url, \%query);
        http_delete($url, \%query);
        http_head($url, \%query);
  HTTP::Request::Common:
    http_get   : sub { require WWW::Curl::Simple; sub { my $ua = WWW::Curl::Simple->new(); $ua->get(@_) } }
    http_post  : sub { require WWW::Curl::Simple; sub { my $ua = WWW::Curl::Simple->new(); $ua->post(@_) } }
    http_put   : sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::PUT(@_)) } }
    http_delete: sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::DELETE(@_)) } }
    http_head  : sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::HEAD(@_)) } }

mail:
  Mail::Sendmail:
    mail_send: |
      sub {
        sub {
          my (%args) = @_;
          my %new;
          $new{ucfirst $_} = $args{$_} for keys %args;
          Mail::Sendmail::sendmail(%new);
          # error $Mail::Sendmail::error;
          # log   $Mail::Sendmail::log;
        }
      }

carp:
  Carp:
    - croak
    - cluck
    - carp
    - confess
    - shortmess
    - longmess

yaml:
  YAML::XS:
    Load:     yaml_load
    Dump:     yaml_dump
    yaml_load_file: sub {require File::Slurp; sub { YAML::XS::Load(File::Slurp::slurp(shift)) }}
    yaml_dump_file: sub {require File::Slurp; sub { File::Slurp::write_file(shift, YAML::XS::Dump(shift))}}

json:
#  JSON::Syck:
#    LoadFile: json_load_file
#    Load:     json_load	    
#    DumpFile: json_dump_file
#    Dump:     json_dump	    
  -require: ['File::Slurp']
  JSON::XS:
    decode_json: json_load
    encode_json: json_dump
    json_load_file: sub {require File::Slurp; sub { JSON::XS::decode_json(File::Slurp::slurp(shift)) }}
    json_dump_file: sub {require File::Slurp; sub { File::Slurp::write_file(shift, JSON::XS::encode_json(shift))}}


basecalc:
  Math::BaseCalc:
    from_base: |
             sub {
                my($pkg, $class, $func, $args, $kind_args) = @_;
                sub {
                   Math::BaseCalc->new(digits => $kind_args->{digits} || $args->{digits})->from_base(shift);
               }
             }
    to_base  : |
             sub {
                my($pkg, $class, $func, $args, $kind_args) = @_;
                sub {
                   Math::BaseCalc->new(digits => $kind_args->{digits} || $args->{digits})->to_base(shift);
                }
             }

datetime:
  -require: ['Date::Manip']
  -as_plugin: 1
  -usage: |
    =head3 functions to return DateTime object
    
      $dt = datetime(year => .., month => ..,);
      $dt = datetime_parse("2009/09/09");
    
    =head3 functions to return DateTime::Duration object
    
      year
      month
      day
      hour
      minute
      second
    
    They return DateTime::Duration object. So you can use them for calcuration.
    
      $duration = year + month + day
    
    You can use plural form of these functions, too which can take number.
    
      years 5;
      months 5;

  DateTime::Duration:
    year   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(years  => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    month  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(months => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    day    : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(days   => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    hour   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(hours  => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    minute : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(minutes => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    second : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(seconds => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    years  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(years  => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    months : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(months => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    days   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(days   => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    hours  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(hours  => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    minutes: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(minutes => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    seconds: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(seconds => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    datetime_duration: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub {DateTime::Duration->new(end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit", @_)}
      }
  Date::Parse:
    datetime_parse: |
      sub {
        my $i = 1;
        unless ($INC{"Date/Manip.pm"}) {
          require Date::Manip;
          $i = 0;
        }
        sub {
          unless ($i) {
            $i = 1;
            Date::Manip::Date_Init();
          }
          my ($ss,$mm,$hh,$day,$month,$year,$zone) = Date::Parse::strptime(@_);
          DateTime->new(year => $year + 1900, month => ++$month, day => $day,
            hour => $hh || 0, minute => $mm || 0, second => $ss || 0,
            time_zone => $Date::Manip::Zone{n2o}->{Time::Zone::tz_name($zone)});
        }
      }
  DateTime:
    today   : sub {sub () { DateTime->today(@_) }}
    now     : sub {sub () { DateTime->now(@_) }}
    datetime: sub {sub { DateTime->new(@_) }}

benchmark:
  Benchmark:
    -select: 
      - timeit
      - timethis
#     -
#        - timethis
#        - timethis($count, \&code)
#        - timethis repeat &code $count times
      - timethese
      - timediff
      - timestr
      - timesum
      - cmpthese
      - countit
    cmpsamearg:
      - | 
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::cmpthese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - cmpsamearg($count, {name => \&code, name2 => \&code}, \%samearg)
    timesamearg:
      - |
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::timethese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - timesamearg($count, {name => \&code, name2 => \&code}, \%samearg)

file:
  File::Find:
    find : file_find
  File::Path:
    - make_path
    - remove_tree
  File::Slurp:
    slurp     : file_slurp
    read_file : file_read
    write_file: file_write
  File::Copy:
    copy: file_copy
    move: file_move

return:
  Return::Value:
    - success
    - failure

time:
  Time::HiRes:
    - usleep
    - nanosleep
    - ualarm

number:
  -as_plugin: 1
  Number::Format:
    commify: |
      sub {
        # code is borrowed from Template::Plugin::Comma
        sub {
          local $_ = shift;
          while (s/((?:\A|[^.0-9])[-+]?\d+)(\d{3})/$1,$2/s){}
          return $_;
        }
      }
    number_round: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args);
        sub {
          $n->round(@_);
        }
      }
    number_format: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_number(@_);
        }
      }
    number_price: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_price(@_);
        }
      }
    number_unit: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_unit(@_);
        }
      }
    to_number: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->unformat_number(@_);
        }
      }