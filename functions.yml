---
scalar:
  Scalar::Util:
    - blessed
    - dualvar
    - isvstring
    - isweak
    - looks_like_number
    - openhandle
    - readonly
    - refaddr
    - reftype
    - set_prototype
    - tainted
    - weaken

list:
  List::Util:
    - first
    - max
    - maxstr
    - min
    - minstr
    - reduce
    - shuffle
    - sum
  List::MoreUtils:
    - after
    - after_incl
    - all
    - any
    - apply
    - before
    - before_incl
    - each_array
    - each_arrayref
    - false
    - first_index
    - first_value
    - firstidx
    - firstval
    - indexes
    - insert_after
    - insert_after_string
    - last_index
    - last_value
    - lastidx
    - lastval
    - mesh
    - minmax
    - natatime
    - none
    - notall
    - pairwise
    - part
    - true
    - uniq
    - zip

hash:
  Hash::Util:
   - hash_seed
   - lock_hash
   - lock_keys
   - lock_value
   - unlock_hash
   - unlock_keys
   - unlock_value

debug:
  Data::Dumper:
    Dumper: dumper
  Data::Dump:
    dump: dump
    p   : sub { sub { Data::Dump::dump(@_) } }

string:
  String::Util:
    - crunch
    - define
    - equndef
    - fullchomp
    - hascontent
    - htmlesc
    - neundef
    - nospace
    - randcrypt
    - randword
    - trim
    - unquote
  String::CamelCase:
    - camelize
    - decamelize
    - wordsplit

md5:
  Digest::MD5:
    - md5
    - md5_hex
    - md5_base64
sha:
  Digest::SHA:
    - sha1
    - sha1_hex
    - sha1_base64
    - sha256
    - sha256_hex
    - sha256_base64
    - sha384
    - sha384_hex
    - sha384_base64
    - sha512
    - sha512_hex
    - sha512_base64

utf8:
  utf8:
    is_utf8  : is_utf8
    upgrade  : utf8_upgrade
    downgrade: utf8_downgrade
    encode   : utf8_encode

cgi:
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape
  HTML::Entities:
    decode_entities: html_entity_decode
    encode_entities: html_entity_encode

html:
  HTML::Entities:
    decode_entities: html_entity_decode
    encode_entities: html_entity_encode
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape

xml:
  -require: ['XML::Parser']
  -as_plugin: 1
  XML::Simple:
    xml_load: |
      sub {
        my ($pkg, $class, $func, $args) = @_;
        local $XML::Simple::XML_SIMPLE_PREFERRED_PARSER = $args->{parser} || 'XML::Parser';
        $args->{Forcearray} ||= $args->{force_array};
        $args->{KeyAttr}    ||= $args->{key_attr};
        sub {
          XML::Simple::XMLin(shift, %$args);
        }
      }
    xml_dump: |
      sub {
        my ($pkg, $class, $func, $args) = @_;
        $args->{KeyAttr} ||= $args->{key_attr};
        sub {
          XML::Simple::XMLout(shift, %$args);
        }
      }

char_enc:
  Encode:
    encode: char_encode
    decode: char_decode
    char_convert: |
      sub {
         my ($pkg, $class, $func, $args) = @_;
         my $g_class = 0;
         if (exists $args->{guess}){
           require Encode::Guess;
           Encode::Guess->import(@{$args->{guess}});
         } elsif (not $INC{"Encode/Detect.pm"} and not $INC{"Encode/Guess.pm"}) {
           eval {require Encode::Detect; $g_class = 1} or require Encode::Guess;
         }
         sub {
           my ($str, $to, $from) = @_;
           Encode::from_to(shift, $from ? $from : $g_class ? "DETECT" : "GUESS", $to);
         }
      }
    from_to: char_from_to

uri:
  URI::Escape:
    - uri_escape
    - uri_unescape
  URI::Split:
    - uri_split
    - uri_join

base64:
  MIME::Base64:
    encode_base64: base64_encode
    decode_base64: base64_decode

http:
  -require : ['LWP::UserAgent']
  HTTP::Request::Common:
    http_get   : sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::GET(@_)) } }
    http_post  : sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::POST(@_)) } }
    http_put   : sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::PUT(@_)) } }
    http_delete: sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::DELETE(@_)) } }
    http_head  : sub { require LWP::UserAgent; sub { my $ua = LWP::UserAgent->new(); $ua->request(HTTP::Request::Common::HEAD(@_)) } }

mail:
  Mail::Sendmail:
    sendmail: mail_send

carp:
  Carp:
    - croak
    - cluck
    - carp
    - confess
    - shortmess
    - longmess

yaml:
  YAML::Syck:
    LoadFile: yaml_load_file
    Load:     yaml_load
    DumpFile: yaml_dump_file
    Dump:     yaml_dump

json:
#  JSON::Syck:
#    LoadFile: json_load_file
#    Load:     json_load	    
#    DumpFile: json_dump_file
#    Dump:     json_dump	    
  -require: ['File::Slurp']
  JSON::XS:
    decode_json: json_load
    encode_json: json_dump
    json_load_file: sub {require File::Slurp; sub { JSON::XS::decode_json(File::Slurp::slurp(shift)) }}
    json_dump_file: sub {require File::Slurp; sub { File::Slurp::write_file(shift, JSON::XS::encode_json(shift))}}


datetime:
  -require: ['Date::Manip']
  -as_plugin: 1
  DateTime::Duration:
    year   : sub {sub () { DateTime::Duration->new(years   => 1) }}
    month  : sub {sub () { DateTime::Duration->new(months  => 1) }}
    day    : sub {sub () { DateTime::Duration->new(days    => 1) }}
    hour   : sub {sub () { DateTime::Duration->new(hours   => 1) }}
    minute : sub {sub () { DateTime::Duration->new(minutes => 1) }}
    second : sub {sub () { DateTime::Duration->new(seconds => 1) }}
    years  : sub {sub ($) { DateTime::Duration->new(years   => shift) }}
    months : sub {sub ($) { DateTime::Duration->new(months  => shift) }}
    days   : sub {sub ($) { DateTime::Duration->new(days    => shift) }}
    hours  : sub {sub ($) { DateTime::Duration->new(hours   => shift) }}
    minutes: sub {sub ($) { DateTime::Duration->new(minutes => shift) }}
    seconds: sub {sub ($) { DateTime::Duration->new(seconds => shift) }}
    datetime_duration: sub {sub {DateTime::Duration->new(@_)}}
  Date::Parse:
    datetime_parse: |
      sub {
        my $i = 1;
        unless ($INC{"Date/Manip.pm"}) {
          require Date::Manip;
          $i = 0;
        }
        sub {
          unless ($i) {
            $i = 1;
            Date::Manip::Date_Init();
          }
          my ($ss,$mm,$hh,$day,$month,$year,$zone) = Date::Parse::strptime(@_);
          DateTime->new(year => $year + 1900, month => ++$month, day => $day,
            hour => $hh || 0, minute => $mm || 0, second => $ss || 0,
            time_zone => $Date::Manip::Zone{n2o}->{Time::Zone::tz_name($zone)});
        }
      }
  DateTime:
    today   : sub {sub () { DateTime->today(@_) }}
    now     : sub {sub () { DateTime->now(@_) }}
    datetime: sub {sub { DateTime->new(@_) }}

benchmark:
  Benchmark:
    - timeit
    - timethis
    - timethese
    - timediff
    - timestr
    - timesum
    - cmpthese
    - countit

file:
  File::Find:
    find : file_find
  File::Path:
    - make_path
    - remove_tree
  File::Slurp:
    slurp     : file_slurp
    read_file : file_read
    write_file: file_write
  File::Copy:
    copy: file_copy
    move: file_move

return:
  Return::Value:
    - success
    - failure
