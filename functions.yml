---
data:
  Scalar::Util:
    - blessed
    - dualvar
    - isvstring
    - isweak
    - looks_like_number
    - openhandle
    - readonly
    - refaddr
    - reftype
    - set_prototype
    - tainted
    - weaken

list:
  List::Util:
    - first
    - max
    - maxstr
    - min
    - minstr
    - reduce
    - shuffle
    - sum
  List::MoreUtils:
    - after
    - after_incl
    - all
    - any
    - apply
    - before
    - before_incl
    - each_array
    - each_arrayref
    - false
    - first_index
    - first_value
    - firstidx
    - firstval
    - indexes
    - insert_after
    - insert_after_string
    - last_index
    - last_value
    - lastidx
    - lastval
    - mesh
    - minmax
    - natatime
    - none
    - notall
    - pairwise
    - part
    - true
    - uniq
    - zip

hash:
  Hash::Util:
    -select:
     - hash_seed
     - lock_hash
     - lock_keys
     - lock_value
     - unlock_hash
     - unlock_keys
     - unlock_value
  Tie::IxHash:
    indexed:
      - |
        sub {
          sub (\%@) {
            my $hash = shift;
            tie %$hash, "Tie::IxHash";
            %$hash = @_;
          }
        }
      - usage:
        - indexed my %hash = (a => 1, b => 2);
        - '%hash is indexed.'
      - test:
        -
          - indexed my %hash; %hash = qw/5 1 4 2 3 3 2 4 1 5 0 6/;  keys %hash
          - qw/5 4 3 2 1 0/
debug:
  -require: ['B::Deparse']
  Data::Dumper:
    Dumper:
      - dumper
      - usage:
        - dumper(@variables)
        - Dumper in L<Data::Dumper>.
    deep_dumper:
      - sub { sub(@) { local $Data::Dumper::Deparse = 1; Data::Dumper::Dumper(@_)} }
      - usage:
        - deep_dumper([1 , 2, sub { print "hello World" }])
        - dump code reference as string. 
#    moose_dumper:
#      - |
#        sub {
#          # written by lesttrat at #soozy on freenode
#          local $Data::Dumper::Sortkeys = sub {
#            my ($hash) = @_;
#            return [ grep { $_ ne '__MOP__' } keys %$hash ];
#          };
#          sub {
#            Data::Dumper::Dumper(@_);
#          }
#        }
#      - usage:
#        - moose_dumper($moose_object)
#        - dump $moose_object except __MOP__
    ex_dumper:
      - |
        sub {
          sub {
            my $keys = pop;
            my %tmp;
            @tmp{@$keys} = ();
            local $Data::Dumper::Sortkeys = sub {
              my ($hash) = @_;
              return [ grep {not exists $tmp{$_}} keys %$hash ];
            };
            Data::Dumper::Dumper(@_);
          }
        }
      - usage:
        - |
          ex_dumper($data, \@keys);
          ex_dumper($data, '__MOP__');
        - dump $data except @keys of hash
  Data::Dump:
    -select: 
      - dump
      - usage:
        - 
          - print dump(@vars);
          - dump(@vars);
        - |
          dump of L<Data::Dumper>. 
          dump strucutre. In later case, result is dumped to STDERR.
      - pp
      - usage:
        - pp("{ x => 1, y => 2, z => 3}");
        - dump after given string is evaled.
      - dd
      - usage:
        - dd(@vars);
        - as same as dump but output to STDOUT.
      - ddx
      - usage:
        - dd(@vars);
        - as same as dd but output to STDOUT with line number.
    p:
      - sub { sub(@) { Data::Dump::dump(@_) } }
      - p($variable)
      - as same as dump(function name is borrowed from Ruby).
    deep_dump:
      - |
        sub {
           sub(@) {
             local $Data::Dumper::Deparse = 1;
             if (not defined wantarray) {
               print STDERR Data::Dumper::Dumper(@_);
             } else {
               return Data::Dumper::Dumper(@_)
             }
          }
        }
      - usage:
        - deep_dump([1,2,3, sub { ... } ]);
        - as same as dump. but it dump code reference as string.
  Tie::Trace:
    -select: ['watch']

string:
  String::Util:
    -select:
      - crunch
      - define
      - equndef
      - fullchomp
      - hascontent
      - htmlesc
      - neundef
      - nospace
      - randcrypt
      - randword
      - trim
      - unquote
    strings:
      - |
        sub {
          sub {
            my $str = shift;
            $str =~ s/\p{Cc}//g;
            return $str;
          }
        }
      - usage:
        - strings("111\0111"); # return '111111'
        - abstract printable characgter from scalar. just like strings command.
  String::CamelCase:
    - camelize
    - decamelize
    - wordsplit
  -test:
    -
      - package test_strings1; use Util::All -string; strings('111' . "\0" . '111');
      - '"111111"'

md5:
  Digest::MD5:
    - md5
    - md5_hex
    - md5_base64
sha:
  Digest::SHA:
    - sha1
    - sha1_hex
    - sha1_base64
    - sha256
    - sha256_hex
    - sha256_base64
    - sha384
    - sha384_hex
    - sha384_base64
    - sha512
    - sha512_hex
    - sha512_base64

utf8:
  utf8:
    is_utf8  : is_utf8
    upgrade  : utf8_upgrade
    downgrade: utf8_downgrade
    encode   : utf8_encode
  Data::Recursive::Encode:
    utf8_on  :
      - sub {sub {Data::Recursive::Encode->decode_utf8(@_)}}
      - my $d = utf8_on($data);
      - recursively make utf8 flag on(not destructive)
    utf8_off :
      - sub {sub {Data::Recursive::Encode->encode_utf8(@_)}}
      - my $d = utf8_off($data);
      - recursively make utf8 flag off(not destructive)
  -test:
    -
      - package test_utf8_1; use Util::All -utf8; my $data = { a => "あ", b => {c => "い"}}; my $d = utf8_on($data); is_utf8($d->{a}) && is_utf8($d->{b}{c});
      - 1
    -
      - package test_utf8_2; use utf8; use Util::All -utf8; my $data = { a => "あ", b => {c => "い"}}; my $d = utf8_off($data); is_utf8($d->{a}) || is_utf8($d->{b}{c});
      - "''"

cgi:
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape
  HTML::Entities:
    decode_entities: html_entity_decode
    html_entity_encode:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          my $_words = $kind_args->{words} || $args->{words};
          sub {
            my ($str, $words);
            if (defined wantarray) {
              ($str, $words) = @_;
              my $s = $str;
              utf8::decode($s)  if not utf8::is_utf8($s);
              $str = HTML::Entities::encode_entities($s, $words || $_words);
            } else {
              ($str, $words) = @_;
              my $ref = \$_[0];
              utf8::decode($str)  if not utf8::is_utf8($str);
              HTML::Entities::encode_entities($str, $words || $_words);
              $$ref = $str;
            }
            return $str;
          }
        }
      - test:
        -
          - no utf8; use Util::All -cgi; html_entity_encode("あいうえお");
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - use utf8; use Util::All -cgi; html_entity_encode("あいうえお");
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - no utf8; use Util::All -cgi; html_entity_encode(my $s = "あいうえお"); $s;
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - use utf8; use Util::All -cgi; html_entity_encode(my $s = "あいうえお"); $s;
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - no utf8; use Util::All -cgi; html_entity_decode(html_entity_encode("あいうえお"));
          - use utf8; 'あいうえお'
        -
          - use utf8; use Util::All -cgi; html_entity_decode(html_entity_encode("あいうえお"));
          - use utf8; 'あいうえお'
        -
          - no utf8; use Util::All -cgi; my $str = "あいうえお"; html_entity_encode($str); $str;
          - "'&#x3042;&#x3044;&#x3046;&#x3048;&#x304A;'"
        -
          - no utf8; use Util::All -cgi; my $str = "あいうえお"; scalar html_entity_encode($str); $str;
          - no utf8; 'あいうえお'
        -
          - package BB;no utf8; use Util::All -cgi => [html_entity_encode => {words => "<>"}]; my $str = "あいうえお<&>"; html_entity_encode($str);
          - use utf8; 'あいうえお&lt;&&gt;'
        -
          - package CC;no utf8; use Util::All -cgi => [-args => {words => "<>"}]; my $str = "あいうえお<&>"; html_entity_encode($str);
          - use utf8; 'あいうえお&lt;&&gt;'
        -
          - package DD;no utf8;use Util::All -cgi => [-args => {words => "<>"}]; my $str = "あいうえお<&>"; html_entity_encode($str, "&");
          - use utf8; 'あいうえお<&amp;>'
  -usage: |
    =head3 html_entity_encode
    
      my $new_str = html_entity_encode($str, $words);
      html_entity_encode($str, $words);
    
    encode HTML entity. in void context, it modify argument itself.
    this function assumes given argument charset is utf8(utf8 flag on or off).
    
    =head3 html_entity_decode
    
      @new_args = html_entity_decode(@args);
      html_entity_decode(@args);
    
    decode HTML entity.  in void context, it modify argument itself.
   
html:
  HTML::Entities:
    decode_entities: html_entity_decode
    encode_entities: html_entity_encode
  CGI::Util:
    escape: cgi_escape
    unescape: cgi_unescape

xml:
  -require: ['XML::Parser']
  -as_plugin: 1
  XML::Simple:
    from_xml: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        local $XML::Simple::XML_SIMPLE_PREFERRED_PARSER = $kind_args->{parser} || $args->{parser} || 'XML::Parser';
        $args->{Forcearray} ||= $kind_args->{force_array} || $args->{force_array};
        $args->{KeyAttr}    ||= $kind_args->{key_attr} || $args->{key_attr};
        sub {
          XML::Simple::XMLin(shift, %$args);
        }
      }
    to_xml: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        $args->{KeyAttr} ||= $kind_args->{key_attr} || $args->{key_attr};
        sub {
          XML::Simple::XMLout(shift, %$args);
        }
      }

encode:
  Encode:
    - encode
    - decode
    - from_to

charset:
  Encode:
    encode: char_encode
    decode: char_decode
    char_convert:
      - |
        sub {
           my ($pkg, $class, $func, $args) = @_;
           my $g_class = 0;
           if (exists $args->{guess}){
             require Encode::Guess;
             Encode::Guess->import(@{$args->{guess}});
           } elsif (not $INC{"Encode/Detect.pm"} and not $INC{"Encode/Guess.pm"}) {
             eval {require Encode::Detect; $g_class = 1} or require Encode::Guess;
           }
           sub {
             my ($str, $to, $from) = @_;
             if (ref $str and utf8::is_utf8($$str)) {
               utf8::encode($$str);
             } elsif (utf8::is_utf8($str)) {
               utf8::encode($str);
             }
             Encode::from_to(ref $str ? $$str : $str, $from ? $from : $g_class ? "DETECT" : "GUESS", $to);
             return $str;
           }
        }
    from_to: char_from_to
  Unicode::Japanese:
   z2h:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2h->$method;
        }
      }
   z2h_kana:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hKana->$method;
        }
      }
   z2h_alpha:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hAlpha->$method;
        }
      }
   z2h_sym:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hSym->$method;
        }
      }
   z2h_num:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->z2hNum->$method;
        }
      }
   h2z:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2z->$method;
        }
      }
   h2z_kana:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zKana->$method;
        }
      }
   h2z_alpha:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zAlpha->$method;
        }
      }
   h2z_sym:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zSym->$method;
        }
      }
   h2z_num:
    - |
      sub {
        sub {
          my $str = shift;
          my $method = utf8::is_utf8($str) ? 'getu' : 'get';
          Unicode::Japanese::unijp($str)->h2zNum->$method;
        }
      }
  -usage: |
    =head3 char_encode / char_decode

    They are encode / decode of Encode.

    =head3 char_convert
    
    old Jocde style function.
    
     $new_str = char_convert($str, "euc-jp"); # to euc-jp
     $new_str = char_convert($str, "euc-jp", "sjis"); # to euc-jp from sjis
    
    convert $str to second argument charset. third argument is charset of $str.
    when third argument is omitted, Encode::Detect(if installed) or Encode::Guess is used to detect charset.
    
    =head3 z2h functions
    
     z2h($str);       # return the value replaced zenkaku to hankaku
     z2h_kana($str);  # return the value replaced zenkaku kana hankaku
     z2h_num($str);   # return the value replaced zenkaku number hankaku
     z2h_sym($str);   # return the value replaced zenkaku symbol hankaku
     z2h_alpha($str); # return the value replaced zenkaku alphabet hankaku

    If $str is utf8 flag on, return utf flagged value, if not return byte string.

    =head3 h2z functions

     h2z($str);       # return the value replaced hankaku to zenkaku
     h2z_kana($str);  # return the value replaced hankaku kana zenkaku
     h2z_num($str);   # return the value replaced hankaku number zenkaku
     h2z_sym($str);   # return the value replaced hankaku symbol zenkaku
     h2z_alpha($str); # return the value replaced hankaku alphabet zenkaku

    If $str is utf8 flag on, return utf flagged value, if not return byte string.
   
  -test:
    - 
      - my $ss = char_convert(my $s = "あ", "euc-jp"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "euc-jp"); $s;
    - 
      - my $ss = char_convert(my $s = "あ", "cp932", "utf8"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "cp932"); $s;
    - 
      - use utf8; my $ss = char_convert(my $s = "あ", "euc-jp"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "euc-jp"); $s;
    - 
      - use utf8; my $ss = char_convert(my $s = "あ", "cp932", "utf8"); $ss
      - my $s = "あ"; Encode::from_to($s, "utf8", "cp932"); $s;
    - 
      - my $ss = char_convert(\(my $s = "あ"), "euc-jp"); $$ss eq $s
      - 1;
    -
      - z2h('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'ｱｲｳｴｵ1234ABCD()*&'"
    -
      - z2h_alpha('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'アイウエオ１２３４ABCD（）＊＆'"
    -
      - z2h_sym('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'アイウエオ１２３４ＡＢＣＤ()*&'"
    -
      - z2h_num('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'アイウエオ1234ＡＢＣＤ（）＊＆'"
    -
      - z2h_kana('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - "'ｱｲｳｴｵ１２３４ＡＢＣＤ（）＊＆'"
    -
      - h2z('ｱｲｳｴｵ1234ABCD()*&')
      - "'アイウエオ１２３４ＡＢＣＤ（）＊＆'"
    -
      - h2z_alpha('ｱｲｳｴｵ1234ABCD()*&')
      - "'ｱｲｳｴｵ1234ＡＢＣＤ()*&'"
    -
      - h2z_sym('ｱｲｳｴｵ1234ABCD()*&')
      - "'ｱｲｳｴｵ1234ABCD（）＊＆'"
    -
      - h2z_num('ｱｲｳｴｵ1234ABCD()*&')
      - "'ｱｲｳｴｵ１２３４ABCD()*&'"
    -
      - h2z_kana('ｱｲｳｴｵ1234ABCD()*&')
      - "'アイウエオ1234ABCD()*&'"
    -
      - use utf8; z2h('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - use utf8; 'ｱｲｳｴｵ1234ABCD()*&'
    -
      - use utf8; z2h('アイウエオ１２３４ＡＢＣＤ（）＊＆')
      - use utf8; 'ｱｲｳｴｵ1234ABCD()*&'

uri:
  URI::Escape:
    - uri_escape
    - uri_unescape
  URI::Split:
    - uri_split
    - uri_join
  URI:
    uri_make:
      - |
        sub {
          sub {
            use utf8;
            my ($url, $form) = @_;
            my %form;
            foreach my $k (keys %$form) {
              my ($key, $value) = ($k, $form->{$k});
              utf8::decode($key)   unless utf8::is_utf8($k);
              utf8::decode($value) unless utf8::is_utf8($value);
              $form{$key} = $value;
            }
            my $u = URI->new($url);
            $u->query_form(%form);
            $u->as_string;
          }
        }
      - usage:
        - uri_make('http://example.com/', { foo => "あ", bar => "い"}); # return 'http://example.com/?bar=%E3%81%84&foo=%E3%81%82'
        - create URI with parameter.
      - test:
        - 
          - uri_make('http://example.com/', { foo => "あ", bar => "い"});
          - ('http://example.com/?bar=%E3%81%84&foo=%E3%81%82')
        - 
          - my $x = "あ"; utf8::decode($x); uri_make('http://example.com/', { foo => $x});
          - ('http://example.com/?foo=%E3%81%82')

base64:
  MIME::Base64:
    encode_base64: base64_encode
    decode_base64: base64_decode
  MIME::Base64::URLSafe:
    urlsafe_b64encode: urlsafe_base64_encode
    urlsafe_b64decode: urlsafe_base64_decode

http:
  -require : ['LWP::UserAgent']
  -usage : |
      =head3 http_* functions
      
      do http method and get HTTP::Response object.
      
        http_get($url, \%query);
        http_post($url, \%query);
        http_put($url, \%query);
        http_delete($url, \%query);
        http_head($url, \%query);
  HTTP::Request::Common:
    http_put   : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::PUT(@_)) } }
    http_delete: sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::DELETE(@_)) } }
    http_head  : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::HEAD(@_)) } }
    http_get   : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::GET(@_)) } }
    http_post  : sub { require LWP::UserAgent; my $ua = LWP::UserAgent->new(); sub { $ua->request(HTTP::Request::Common::POST(@_)) } }
#  WWW::Curl::Simple is faster, but hard to install:
#    http_get   : sub { require WWW::Curl::Simple; my $ua = WWW::Curl::Simple->new(); sub { $ua->get(@_) } }
#    http_post  : sub { require WWW::Curl::Simple; my $ua = WWW::Curl::Simple->new(); sub { $ua->post(@_) } }

email:
  -as_plugin: 1
  -require: ['File::Slurp', 'MIME::Types', 'Clone', 'Template']
  Email::MIME:
    create_email: |
      sub {
        my ($pkg, $class, $func, $args) = @_;
        require Clone;
        require MIME::Types;
        require File::Slurp;
        my $mime = MIME::Types->new;
        my $charset_resolver = sub {
           my ($attributes, $header) = @_;
           my $charset = $attributes->{charset} || '';
           if ($charset =~m{iso[-_]2022[-_]jp}o or $charset =~m{\bjis$}o) {
             $charset = '';
             my $i = 0;
             foreach my $head (@$header) {
               next if ++$i % 2;
               Encode::from_to($head, "iso-2022-jp", 'MIME-Header-ISO_2022_JP');
               # $head = Encode::encode('MIME-Header-ISO_2022_JP' => $head);
             }
             $attributes->{encoding} = '7bit';
           } elsif($charset) {
             $attributes->{encoding} = 'base64';
           }
           return $charset;
        };
        sub {
          my ($header, $attributes, $parts_or_body) = @_;
          $attributes    = Clone::clone($attributes);
          $parts_or_body = Clone::clone($parts_or_body) if ref $parts_or_body;
          my $charset = $charset_resolver->($attributes, $header);
          if (ref $parts_or_body) {
            # multipart
            Email::MIME->create(attributes => $attributes,
                                parts => [map {
                                      my (@arg, $charset);
                                      my ($attributes, $body_or_file) = ref $_ ? (@$_) : ({}, $_);
                                      if (-e $body_or_file) {
                                        # is file
                                        my ($ext) = $body_or_file =~m{\.(.+?)$};
                                        my $attr = {content_type => $mime->mimeTypeOf($ext), encoding => "base64"};
                                        @arg = (body => scalar File::Slurp::slurp($body_or_file),
                                                attributes => $attr);
                                      } else {
                                        $charset = $charset_resolver->($attributes, {});
                                        @arg = (attributes => $attributes, body => $body_or_file);
                                      }
                                      Email::MIME->create(@arg);
                                    } @$parts_or_body],
                                ($charset ? 'header_str' : 'header') => $header);
          } else {
            # singlepart
            $attributes->{content_type} ||= 'text/plain';
            Email::MIME->create(attributes => $attributes,
                                ($charset ? 'body_str' : 'body') => $parts_or_body,
                                ($charset ? 'header_str' : 'header') => $header);
          }
        }
      }
    parse_email: |
       sub {
         sub {
            my $src = shift;
            return Email::MIME->new($src);
         }
       }
  Email::Sender::Simple:
    send_email: |
       sub {
         use strict;
         unless (defined &sendmail) {
           Email::Sender::Simple->import('sendmail');
         }
         sub {
            no strict 'refs';
            my $pkg = (caller)[0];
            my $opt = {};
            $opt = pop if ref $_[-1] eq 'HASH';
            my $mime = sendmail(@_ == 1 ? (@_) : &{$pkg . '::' . 'create_email'}(@_), $opt);
         }
       }
    send_template_email: |
      sub {
         use strict;
         require Template;
         unless (defined &sendmail) {
           Email::Sender::Simple->import('sendmail');
         }
         sub {
            my $pkg = (caller)[0];
            my ($file_or_scalarref, $params) = @_;
            my $tt = Template->new(
               INTERPOLATE  => 1,
               ABSOLUTE     => 1,
               RELATIVE     => 1,
               );
            my $body;
            $tt->process($file_or_scalarref, $params, \$body);
            my %header;
            if ($body =~s{^(.+?)--\s*}{}s and my $header = $1) {
               foreach my $kv (split /[\r\n]+/, $header) {
                 my ($k, $v) = split /\s*:\s*/, $kv, 2;
                 $header{ucfirst $k} =  $v;
               }
            }
            no strict 'refs';
            my $mime = sendmail(&{$pkg . '::' . 'create_email'}([%header], {}, $body));
         }
      }
  -usage: |
     =head3 examples

     You have to pass encoded arguments.

       # multipart email
       my @parts = ([$body, $attribute], [$body2, $attribute2]);
       my $email = create_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, \@parts);
       send_email($email);
  
       # multipart email
       my $email = create_email([To => 'from@example.com', Subject => "さぶじぇくと"], {charset => "jis"},
                                [[{content_type => "text/plain", charset => "utf8"}, "まるちばいと"],
                                 "example.jpg"]);
       send_email($email);
  
       # singlepart email
       my $email = create_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, $body);
       send_email($email);
  
       # send_email with create_email
       send_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, \@parts);
       send_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, $body, {transport => $transport});
       

       # send_template_email (singlepart only)
       send_template_email($template_file, $parameter)
       # $template_file is like the following
       #
       #   From:
       #   To: 
       #   Subject: 
       #   --
       #   Hello, World!
       #   Hello, World!
       #   Hello, World!
       #
       # header is begore '--'. data part is aftrer '--'.
  
       # parse_email
       parse_email($email_src); # currently just returns Email::MIME object

     =head3 send_email

       send_email($email);
       send_email($email, $options);
       send_email($header, $attributes, $body, $options);
       send_email($header, $attributes, \@parts, $options);
     
     arguments is Email::MIME object(create_email returns) or
     arguments as same as create_email.
     As an additional argument, you can put hash ref as last argument
     which is equal to last argument of Email::Sender::Simple's sendmail.

carp:
  Carp:
    - croak
    - cluck
    - carp
    - confess
    - shortmess
    - longmess

yaml: &yaml
  -require: ['File::Slurp']
  YAML::XS:
    Load: from_yaml
    Dump: to_yaml
    from_yaml_file:
      - sub {require File::Slurp; sub ($) { YAML::XS::Load(scalar File::Slurp::slurp(shift)) }}
      - from_yaml_file($yaml_file);
      - load YAML data from file
    to_yaml_file:
      - sub {require File::Slurp; sub { File::Slurp::write_file(shift, YAML::XS::Dump(shift))}}
      - to_yaml_file($yaml_file);
      - dump YAML data to file
  -test:
    -
      - package test_yaml; use Util::All -yaml, -debug; dump from_yaml(to_yaml({hoge => 1}));
      - "'{ hoge => 1 }'"
    - 
      - package test_yaml; use Util::All -yaml; to_yaml(from_yaml_file("t/data/test.yml"));
      - '"---\nhoge: 1\n"'

# yml: *yaml

json:
  -require: ['File::Slurp']
  JSON::XS:
    decode_json: from_json
    encode_json: to_json
    from_json_file:
      - sub {require File::Slurp; sub ($) { JSON::XS::decode_json(scalar File::Slurp::slurp(shift)) }}
      - from_json_file($json_file);
      - load JSON data from file
    to_json_file:
      - sub {require File::Slurp; sub { File::Slurp::write_file(shift, JSON::XS::encode_json(shift))}}
      - from_json_file($json_file);
      - load JSON data from file
  -test:
    -
      - package test_json; use Util::All -json, -debug; dump from_json(to_json({hoge => 1}));
      - "'{ hoge => 1 }'"
    - 
      - package test_json; use Util::All -json; to_json(from_json_file("t/data/test.json"));
      - 'qq{{"hoge":1}}'

basecalc:
  Math::BaseCalc:
    from_base:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
            sub {
            Math::BaseCalc->new(digits => $kind_args->{digits} || $args->{digits})->from_base(shift);
          }
        }
    to_base :
      - |
        sub {
           my($pkg, $class, $func, $args, $kind_args) = @_;
           sub {
              Math::BaseCalc->new(digits => $kind_args->{digits} || $args->{digits})->to_base(shift);
           }
        }
  -usage: |
    =head3 from_base / to_base

      use Util::All -basecalc => {-args => {digits => [0,1]}};
      to_base(4);     # 100
      from_base(100); # 4
 
  -test :
    -
      - package test_basecalc1; use Util::All -basecalc => {-args => {digits => [0,1]}}; (to_base(4), from_base(100));
      - 100, 4
    -
      - package test_basecalc2; use Util::All -basecalc => [to_base => {digits => [0,1], -as => 'to_base2'}]; to_base2(4);
      - 100
    -
      - package test_basecalc3; use Util::All -basecalc => [from_base => {digits => [0,1], -as => 'from_base2'}]; from_base2(100);
      - 4

datetime: &datetime
  -require: ['Date::Manip']
  -as_plugin: 1
  -usage: |
    =head3 functions to return DateTime object
    
      $dt = datetime(year => .., month => ..,);
      $dt = datetime_parse("2009/09/09");
      $dt = now;
      $dt = today;
    
    =head3 functions to return DateTime::Duration object
    
    NOTE THAT: end_of_month is set as limit.
      
      year
      month
      day
      hour
      minute
      second
    
    They return DateTime::Duration object. So you can use them for calcuration.
    
      $duration = year + month + day
    
    You can use plural form of these functions, too which can take number.
    
      years 5;
      months 5;

    example:
    
      $after_five_year_from_now = now + years 5;

    =head3 How to change end_of_month?

      use Util::All -datetime => [-args => {end_of_month => 'wrap'}];

  -test:
    - 
      - package test_datetime1; use Util::All '-datetime'; my $dt = datetime_parse("1970/01/01"); $dt += year; $dt->year;
      - 1971
    - 
      - package test_datetime2; use Util::All '-datetime'; my $dt = datetime_parse("1970/01/01"); $dt += years 2; $dt->year;
      - 1972
    - 
      - package test_datetime3; use Util::All '-datetime'; my $dt = datetime_parse("1970/02/01"); $dt += month; $dt->day;
      - 1
    - 
      - package test_datetime4; use Util::All '-datetime'; year->end_of_month_mode;
      - ('limit')
    - 
      - package test_datetime5; use Util::All '-datetime' => [-args => {end_of_month => 'wrap'}]; year->end_of_month_mode;
      - ('wrap')
    - 
      - package test_datetime6; use Util::All '-datetime' => ['month', year => {end_of_month => 'preserve'}]; join ' ', year->end_of_month_mode, month->end_of_month_mode;
      - ('preserve limit')
    - 
      - package test_datetime7; use Util::All '-datetime' => ['year', month => {end_of_month => 'wrap'}]; join ' ', month->end_of_month_mode, year->end_of_month_mode;
      - ('wrap limit')
    - 
      - package test_datetime8; use Util::All '-datetime' => ['day', days => {end_of_month => 'preserve'}]; join ' ', days(5)->end_of_month_mode, day->end_of_month_mode;
      - ('preserve limit')

  DateTime::Duration:
    year   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(years  => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    month  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(months => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    day    : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(days   => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    hour   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(hours  => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    minute : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(minutes => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    second : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub () { DateTime::Duration->new(seconds => 1, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    years  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(years  => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    months : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(months => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    days   : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(days   => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    hours  : |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(hours  => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    minutes: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(minutes => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    seconds: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub ($) { DateTime::Duration->new(seconds => shift, end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit") }
      }
    datetime_duration: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        sub {DateTime::Duration->new(end_of_month => $kind_args->{end_of_month} || $args->{end_of_month} || "limit", @_)}
      }
  Date::Parse:
    datetime_parse: |
      sub {
        my $i = 1;
        unless ($INC{"Date/Manip.pm"}) {
          require Date::Manip;
          $i = 0;
        }
        sub {
          unless ($i) {
            $i = 1;
            Date::Manip::Date_Init();
          }
          my ($ss,$mm,$hh,$day,$month,$year,$zone) = Date::Parse::strptime(@_);
          DateTime->new(year => $year + 1900, month => ++$month, day => $day,
            hour => $hh || 0, minute => $mm || 0, second => $ss || 0,
            time_zone => $Date::Manip::Zone{n2o}->{Time::Zone::tz_name($zone)} || 'local');
        }
      }
  DateTime:
    today   : sub {sub () { DateTime->today(@_) }}
    now     : sub {sub () { DateTime->now(@_) }}
    datetime: sub {sub { DateTime->new(@_) }}

# date: *datetime

benchmark:
  Benchmark:
    -select: 
      - timeit
      - timethis
#     - usage:
#        - timethis
#        - timethis($count, \&code)
#        - timethis repeat &code $count times
      - timethese
      - timediff
      - timestr
      - timesum
      - cmpthese
      - countit
    cmpsamearg:
      - | 
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::cmpthese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - usage:
        - cmpsamearg($count, {name => \&code, name2 => \&code}, \%samearg)
        - like cmpthese but compare 2 code with same argument
    timesamearg:
      - |
        sub {
          sub {
            my ($num, $codes, @args) = @_;
            Benchmark::timethese($num, {map {my $code = $codes->{$_}; $_ => sub {$code->(@args)} } keys %$codes});
          }
        }
      - usage:
        - timesamearg($count, {name => \&code, name2 => \&code}, \%samearg)
        - like timethese but compare 2 code with same argument

file:
  File::Find:
    find : find_file
  File::Path:
    - make_path
    - remove_tree
  File::Slurp:
    -select   :
      - read_file
      - write_file
    slurp     : slurp_file
  File::Copy:
    copy: copy_file
    move: move_file
  File::Temp:
    tempfile:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
          sub {
            my @args = @_;
            my %args = (%$kind_args, %$args, @args % 2 ? (TEMPLATE => shift @args) : @args);
            my %new_args = map {uc($_) => $args{$_}} keys %args;
            if (exists $new_args{TEMPLATE}) {
              if ($new_args{TEMPLATE} =~s{\*(.+)$}{XXXX}) {
                 $new_args{SUFFIX} = $1;
              }
              if ($new_args{TEMPLATE} !~ /XXXX$/) {
                $new_args{TEMPLATE} .= "XXXX"
              }
            }
            File::Temp->new(%new_args);
          }
        }
      - usage:
        - |
          tempfile("anyname*.dat")
          tempfile("anyname*.dat", dir => '/var/tmp')
          tempfile("anyname*", dir => '/var/tmp', suffix => '.dat', exlock => 1)
    locked_tempfile:
      - |
        sub {
          my($pkg, $class, $func, $args, $kind_args) = @_;
          # %args = map {uc($_) => $args->{$_}} keys %$args;
          # %kind_args = map {uc($_) => $args->{$_}} keys %$kind_args;
          sub {
            my @args = @_;
            my %args = (%$kind_args, %$args, @args % 2 ? (TEMPLATE => shift @args) : @args);
            my %new_args = map {uc($_) => $args{$_}} keys %args;
            if (exists $new_args{TEMPLATE}) {
              if ($new_args{TEMPLATE} =~s{\*(.+)$}{XXXX}) {
                 $new_args{SUFFIX} = $1;
              }
              if ($new_args{TEMPLATE} !~ /XXXX$/) {
                $new_args{TEMPLATE} .= "XXXX"
              }
            }
            File::Temp->new(%new_args, EXLOCK => 1);
          }
        }
    file_base64:
        - |
         sub {
           require File::Slurp;
           require MIME::Base64;
           sub {
             my ($file) = @_;
             my $d = File::Slurp::slurp($file);
             return MIME::Base64::encode_base64($d);
           }
         }

# bool:
#   Return::Value:
#     - 'success'
#     - 'failure'
#   -usage: |
#      sub yatta { success("OK") }
#      if (my $r = yatta) {
#         print $r; # "OK";
#      }
#      sub orz { success("NG") }
#      unless (my $r = orz) {
#         print $r; # "NG";
#      }
#   -test:
#     - 
#       - 'success("yatta") ? 1 : 0;'
#       - 1
#     - 
#       - 'failure("orz") ? 1 : 0;'
#       - 0
#     - 
#       - my $x = success("yatta");
#       - ("yatta")
#     - 
#       - my $x = failure("orz");
#       - ("orz")

utime:
  Time::HiRes:
    - usleep
    - nanosleep
    - ualarm

number:
  -as_plugin: 1
  Number::Format:
    number_commify: |
      sub {
        # code is borrowed from Template::Plugin::Comma
        sub {
          local $_ = shift;
          while (s/((?:\A|[^.0-9])[-+]?\d+)(\d{3})/$1,$2/s){}
          return $_;
        }
      }
    number_round: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args);
        sub {
          $n->round(@_);
        }
      }
    number_format: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_number(@_);
        }
      }
    number_price: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_price(@_);
        }
      }
    number_unit: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->format_bytes(@_);
        }
      }
    to_number: |
      sub {
        my ($pkg, $class, $func, $args, $kind_args) = @_;
        my $n = Number::Format->new(%$kind_args, %$args);
        sub {
          $n->unformat_number(@_);
        }
      }
  -test:
    -
      - number_commify(10000);
      - ('10,000')
    -
      - number_price(10000);
      - Number::Format->new->format_price(10000);
    -
      - number_round(123, -2);
      - 100
    -
      - number_round(123.25, 1);
      - 123.3
    -
      - number_unit(1024, unit => 'K', mode => 'iec')
      - ('1KiB')
    -
      - number_unit(1048576, unit => 'M', mode => 'trad')
      - ('1M')
    -
      - to_number('1,000');
      - 1000
    -
      - to_number('1,025');
      - 1025
    -
      - to_number('1KiB');
      - 1024
image:
  -as_plugin: 1
  -require : ['MIME::Base64', 'File::Slurp']
  Imager:
    convert_image:
      - |
        sub {
          sub {
            my ($before, $after) = @_;
            $after ||= '';
            my $img = Imager->new;
            $img->read(file => $before) or die $img->errstr;
            if ($after !~ /\./) {
              my $i;
              $img->write(data => \$i, type => $after) or die $img->errstr;
              print $i;
            } else {
              $img->write(file => $after) or die $img->errstr;
            }
            return $img;
          }
        }
      - usage:
        - |
          convert_image("before.jpg", "after.png");
          convert_image("before.jpg", "png"); # output to stdout as ping
        - convert images to other format.
    resize_image:
      - |
        sub {
          sub ($@){
            my ($before, $after, @conf) = @_;
            $after ||= '';
            my $img = Imager->new;
            $img->read(file => $before) or die $img->errstr;
            my %conf;
            if (ref $conf[0] eq 'ARRAY') {
              $conf{xpixels} = $conf[0]->[0];
              $conf{ypixels} = $conf[0]->[1];
              $conf{type} = 'nonprop';
            } elsif(@conf == 1 and not ref $conf[0]) {
              $conf{scalefactor} = $conf[0];
            } else {
                %conf = @conf;
            }
            my $newimg = $img->scale(%conf);
            if ($after !~ /\./) {
              my $i;
              $newimg->write(data => \$i, type => $after) or die $newimg->errstr;
              print $i;
            } else {
              $newimg->write(file => $after) or die $newimg->errstr;
            }
            return $newimg;
          }
        }
      - usage:
        - |
          resize_image("before.jpg", "after.png", %option);
          resize_image("before.jpg", "after.png", [200, 100]); # 200x100px
          resize_image("before.jpg", "after.png", 0.5); # 1/2 scale
          resize_image("before.jpg", "png", 0.5);  # output 1/2 scale image to STDOUT as ping
        - |
          resize image.
  Image::Info:
    image_info:
      - |
        sub {
          sub {
            my ($file) = @_;
            my $info = Image::Info::image_info($file);
            if (ref $info eq 'HASH' and exists $info->{error}) {
              die $info->{error};
            }
            return $info
          }
        }
      - usage:
        - my $info = image_info("picture.jpg");
        - return image information(Image::Info)
    image_type:
      - |
        sub {
          sub {
            my ($file) = @_;
            my $type = Image::Info::image_type($file);
            if (exists $type->{error}) {
              die $type->{error};
            }
            return $type->{file_type};
          }
        }
      - usage:
        - my $info = image_type("picture.jpg");
        - return image type(Image::Info)

exception:
  Try::Tiny:
    - try
    - catch

csv:
  -as_plugin: 1
  Text::CSV:
    parse_csv:
      - |
        sub {
          my ($pkg, $class, $func, $args, $kind_args) = @_;
          $args ||= {};
          $kind_args ||= {};
          use strict;
          if (not defined &Util::All::_Tmp::Text::CSV_XS::next) {
            no strict 'refs';
            *{"Util::All::_Tmp::Text::CSV_XS::next"} = sub { my $self = shift; my $r; $r = $self->{sub}->() or (!$self->{pass_fh} and close $self->{fh}); return $r}
          }
          sub {
            my $pass_fh = 0;
            my ($fh, $column_names) = @_;
            my $csv = Text::CSV_XS->new({binary => 1, %$kind_args, %$args});
            unless (ref $fh) {
              my $file = $fh;
              undef $fh;
              open($fh, '<', $file) or Carp::croak("cannot open file: $file");
            } else {
              $pass_fh = 1;
            }
            my $sub;
            if (@_ == 2) {
              $csv->column_names($column_names);
              $sub = sub {$csv->getline_hr($fh)};
            } else {
              $sub = sub {$csv->getline($fh)};
            }
            return bless {sub => $sub, fh => $fh, pass_fh => $pass_fh} => "Util::All::_Tmp::Text::CSV_XS";
          }
        }
      - usage:
        - |
          use Util::All -csv;
          
          my $csv = parse_csv($file_or_fh);
          while (my $ar = $csv->next) {
             print "@$ar\n";
          }
          
          my $csv = parse_csv($file_or_fh, ['name', 'age']);
          while (my $hr = $csv->next) {
             print jion " ", %$hr, "\n";
          }
          
          # pass options to Text::CSV_XS
          use Util::All -csv => {-args => {binary => 0, eol => "\r\n"}};
  -test:
    -
      - package test_csv1; use Util::All -csv; my $csv = parse_csv("t/data/test.csv"); my $sum = 0; while (my $l = $csv->next) {$sum +=$l->[1]}; $sum;
      - 223
    -
      - package test_csv2; use Util::All -csv; my $csv = parse_csv("t/data/test.csv", ['l', 'num']); my $label = ''; while (my $l = $csv->next) {$label .=$l->{l}}; $label;
      - '"abcdefアイウエオ"'
    -
      - package test_csv3; use Util::All -csv; open my $fh, "t/data/test.csv"; my $csv = parse_csv($fh); my $sum = 0; while (my $l = $csv->next) {$sum +=$l->[1]}; $sum;
      - 223
    -
      - package test_csv4; use Util::All -csv; open my $fh, "t/data/test.csv"; my $csv = parse_csv($fh); 1 while $csv->next; tell $fh;
      - 49

prompt:
  -as_plugin: 1
  IO::Prompt:
    -select:
      - prompt
    required_prompt:
      - |
        sub {
          sub {
            my $message = shift;
            my $answer;
          PROMPT:
            {
              $answer = IO::Prompt::prompt($message, @_);
              $answer->{value} or redo PROMPT;
              return $answer->{value};
            }
          }
        }
    password_prompt:
      - |
        sub {
          sub {
            my $message = shift;
            my $answer;
            $answer = IO::Prompt::prompt($message, -echo => "*", @_);
            $answer->{value};
          }
        }

