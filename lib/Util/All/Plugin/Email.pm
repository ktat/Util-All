package Util::All::Plugin::Email;

use warnings;
use strict;

use Util::Any -Base, -Pluggable;

sub utils {
  {
  '-email' => [
    [
      'Email::Sender::Simple',
      '',
      {
        'send_template_email' => sub {
            use strict 'refs';
            require Template;
            unless (defined &sendmail) {
                'Email::Sender::Simple'->import('sendmail');
            }
            sub {
                my $pkg = (caller)[0];
                my $opt = {};
                $opt = pop @_ if @_ > 2 and ref $_[-1] eq 'HASH';
                my($file_or_scalarref, $params, $attr) = @_;
                my $tt = 'Template'->new('INTERPOLATE', 1, 'ABSOLUTE', 1, 'RELATIVE', 1);
                my $body;
                $tt->process($file_or_scalarref, $params, \$body);
                my %header;
                if ($body =~ s/^(.+?)--\s*//s and my $header = $1) {
                    foreach my $kv (split(/[\r\n]+/, $header, 0)) {
                        my($k, $v) = split(/\s*:\s*/, $kv, 2);
                        $header{ucfirst $k} = $v;
                    }
                }
                no strict 'refs';
                my $mime = sendmail(&{$pkg . '::' . 'create_email';}([%header], $attr, $body));
            }
            ;
        },
        '-select' => [],
        'send_email' => sub {
            use strict 'refs';
            unless (defined &sendmail) {
                'Email::Sender::Simple'->import('sendmail');
            }
            sub {
                no strict 'refs';
                my $pkg = (caller)[0];
                my $opt = {};
                $opt = pop @_ if ref $_[-1] eq 'HASH';
                my $mime = sendmail(@_ == 1 ? @_ : &{$pkg . '::' . 'create_email';}(@_), $opt);
            }
            ;
        }
      }
    ],
    [
      'Email::MIME',
      '',
      {
        'parse_email' => sub {
            sub {
                my $src = shift @_;
                return 'Email::MIME'->new($src);
            }
            ;
        },
        '-select' => [],
        'create_email' => sub {
            my($pkg, $class, $func, $args) = @_;
            require Clone;
            require MIME::Types;
            require File::Slurp;
            my $mime = 'MIME::Types'->new;
            my $charset_resolver = sub {
                my($attributes, $header) = @_;
                my $charset = $$attributes{'charset'} || '';
                if ($charset =~ /iso[-_]2022[-_]jp/o or $charset =~ /\bjis$/o) {
                    $charset = '';
                    my $i = 0;
                    foreach my $head (@$header) {
                        next if ++$i % 2;
                        Encode::from_to($head, 'iso-2022-jp', 'MIME-Header-ISO_2022_JP');
                    }
                    $$attributes{'encoding'} = '7bit';
                }
                elsif ($charset) {
                    $$attributes{'encoding'} = 'base64';
                }
                return $charset;
            }
            ;
            sub {
                my($header, $attributes, $parts_or_body) = @_;
                $attributes = Clone::clone($attributes);
                $parts_or_body = Clone::clone($parts_or_body) if ref $parts_or_body;
                my $charset = &$charset_resolver($attributes, $header);
                if (ref $parts_or_body) {
                    'Email::MIME'->create('attributes', $attributes, 'parts', [map({my(@arg, $charset);
                    my($attributes, $body_or_file) = ref $_ ? @$_ : ({}, $_);
                    if (-e $body_or_file) {
                        my($ext) = $body_or_file =~ /\.(.+?)$/;
                        my $attr = {'content_type', $mime->mimeTypeOf($ext), 'encoding', 'base64'};
                        @arg = ('body', scalar File::Slurp::slurp($body_or_file), 'attributes', $attr);
                    }
                    else {
                        $charset = &$charset_resolver($attributes, {});
                        @arg = ('attributes', $attributes, 'body', $body_or_file);
                    }
                    'Email::MIME'->create(@arg);} @$parts_or_body)], $charset ? 'header_str' : 'header', $header);
                }
                else {
                    $$attributes{'content_type'} ||= 'text/plain';
                    'Email::MIME'->create('attributes', $attributes, $charset ? 'body_str' : 'body', $parts_or_body, $charset ? 'header_str' : 'header', $header);
                }
            }
            ;
        }
      }
    ]
  ]
}
;
}

=head1 NAME

Util::All -  (alpha software) collect perl utilities and group them by appropriate kind.

=cut

our $VERSION = '0.01';

=head1 SYNOPSIS

=head1 EXPORT

functions which C<*> follows are generated by the way like Sub::Exporter.
see L<Util::Any/"USE Sub::Exporter's GENERATOR WAY">

=head2 -email

=head3 examples

You have to pass encoded arguments.

  # multipart email
  my @parts = ([$body, $attribute], [$body2, $attribute2]);
  my $email = create_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, \@parts);
  send_email($email);

  # multipart email
  my $email = create_email([To => 'from@example.com', Subject => "さぶじぇくと"], {charset => "jis"},
                           [[{content_type => "text/plain", charset => "utf8"}, "まるちばいと"],
                            "example.jpg"]);
  send_email($email);

  # singlepart email
  my $email = create_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, $body);
  send_email($email);

  # send_email with create_email
  send_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, \@parts);
  send_email([From => 'from@example.com'], {'content_type' => 'text/plain'}, $body, {transport => $transport});


  # send_template_email (singlepart only)
  send_template_email($template_file, $parameter, {'content_type' => 'text/plain'}, {transport => $transprot})
  # $template_file is like the following
  #
  #   From:
  #   To: 
  #   Subject: 
  #   --
  #   Hello, World!
  #   Hello, World!
  #   Hello, World!
  #
  # header is begore '--'. data part is aftrer '--'.

  # parse_email
  parse_email($email_src); # currently just returns Email::MIME object

=head3 send_email

  send_email($email);
  send_email($email, $options);
  send_email($header, $attributes, $body, $options);
  send_email($header, $attributes, \@parts, $options);

arguments is Email::MIME object(create_email returns) or
arguments as same as create_email.
As an additional argument, you can put hash ref as last argument
which is equal to last argument of Email::Sender::Simple's sendmail.


=head3 function enable to rename *

send_template_email, send_email, parse_email, create_email



=head1 AUTHOR

Ktat, C<< <ktat at cpan.org> >>

=head1 REPOSITORY

Util::All is hosted at github.

L<http://github.com/ktat/Util-All>

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

 perldoc Util::All::Email

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Util-All>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Util-All>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Util-All>

=item * Search CPAN

L<http://search.cpan.org/dist/Util-All/>

=back

=head1 ACKNOWLEDGEMENTS

Thanks to All Perl Users.
When I find useful code, I write it here as memo.

=head1 SEE ALSO

=over 4

=item L<Util::Any>

This module is based on Util::Any.
Util::Any helps you to create your own utility module.

=back

=head1 COPYRIGHT & LICENSE

Copyright 2009-2010 Ktat, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1;